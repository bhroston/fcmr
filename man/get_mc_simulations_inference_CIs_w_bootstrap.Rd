% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/utils-monte_carlo_model_generation_and_simulation.R
\name{get_mc_simulations_inference_CIs_w_bootstrap}
\alias{get_mc_simulations_inference_CIs_w_bootstrap}
\title{Calculate Inferences (w/ Confidence Intervals via Bootstrap) of MC FCM Simulations}
\usage{
get_mc_simulations_inference_CIs_w_bootstrap(
  mc_simulations_inference_df = data.frame(),
  inference_function = "mean",
  confidence_interval = 0.95,
  bootstrap_reps = 1000,
  parallel = TRUE,
  n_cores = integer(),
  show_progress = TRUE
)
}
\arguments{
\item{mc_simulations_inference_df}{The final values of a set of fcm simulations; also the inference of a infer_fmcm object}

\item{inference_function}{Estimate confidence intervals about the "mean" or "median" of
inferences from the monte carlo simulations}

\item{confidence_interval}{What are of the distribution should be bounded by the
confidence intervals? (e.g. 0.95)}

\item{bootstrap_reps}{Repetitions for bootstrap process, if chosen}

\item{parallel}{TRUE/FALSE Whether to perform the function using parallel processing}

\item{n_cores}{Number of cores to use in parallel processing. If no input given,
will use all available cores in the machine.}

\item{show_progress}{TRUE/FALSE Show progress bar when creating fmcm. Uses pbmapply
from the pbapply package as the underlying function.}
}
\value{
A list of raw bootstrap draws and a dataframe of confidence intervals
}
\description{
This gets the mean of the distribution of simulated values
across a given iter. Also returns the bootstrapped mean of means of the
distribution of simulated values across a given iter if called.
}
\details{
This function is designed to streamline the process of getting the mean or bootstrapped
mean of means of a distribution of simulated values across individual iterations. Use get_bootstrapped_means
to estimate the confidence intervals for the mean value across simulations.

The show_progress and parallel inputs change the functions called, but do NOT
change the output! These are allowed to be toggled on/off to increase user
control at runtime.
}
\examples{
ex_adj_matrix_1 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0, 0, 0, 1),
  "C" = c(0, 1, 0, 0),
  "D" = c(0, 0, 1, 0)
)
ex_adj_matrix_2 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0.25, 0, 0, 0.25),
  "C" = c(0, 0.25, 0, 0),
  "D" = c(0, 0, 0.25, 0)
)
ex_adj_matrix_3 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0.75, 0, 0, 0.75),
  "C" = c(0, 0.75, 0, 0),
  "D" = c(0, 0, 0.75, 0)
)
ex_adj_matrix_4 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0.5, 0, 0, 0.5),
  "C" = c(0, 0.5, 0, 0),
  "D" = c(0, 0, 0.5, 0)
)
ex_fcms <- list(
  ex_adj_matrix_1, ex_adj_matrix_2, ex_adj_matrix_3, ex_adj_matrix_4
)

mc_fcms <- build_monte_carlo_fcms_from_conventional_adj_matrices(
  ex_fcms, N_samples = 100, include_zeroes = FALSE, show_progress = TRUE
)

mc_fcms_inferences <- infer_fcm_set(
  adj_matrices = mc_fcms,
  initial_state_vector <- c(1, 1, 1, 1),
  clamping_vector <- c(1, 0, 0, 0),
  activation = "kosko",
  squashing = "sigmoid",
  lambda = 1,
  point_of_inference = "final",
  max_iter = 1000,
  min_error = 1e-5,
  parallel = FALSE,
  show_progress = TRUE
)

mc_sims_inferences <- get_mc_simulations_inference_CIs_w_bootstrap(
  mc_fcms_inferences$inference, "median", 0.95, parallel = FALSE
)

}
\seealso{
Other monte-carlo-model-generation-and-simulation: 
\code{\link{build_monte_carlo_fcms}()},
\code{\link{build_monte_carlo_fcms_from_conventional_adj_matrices}()},
\code{\link{build_monte_carlo_fcms_from_fuzzy_set_adj_matrices}()},
\code{\link{check_build_monte_carlo_fcms_inputs}()},
\code{\link{check_infer_fcm_set_inputs}()},
\code{\link{check_monte_carlo_bootstrap_inputs}()},
\code{\link{infer_fcm_set}()}
}
\concept{monte-carlo-model-generation-and-simulation}
\keyword{internal}
