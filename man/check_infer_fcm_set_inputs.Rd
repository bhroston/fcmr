% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-infer_and_simulate_fcm.R
\name{check_infer_fcm_set_inputs}
\alias{check_infer_fcm_set_inputs}
\title{Check inputs for running infer_fcm on a list of adj. matrices}
\usage{
check_infer_fcm_set_inputs(
  adj_matrices = list(matrix()),
  initial_state_vector = c(),
  clamping_vector = c(),
  activation = c("kosko", "modified-kosko", "rescale"),
  squashing = c("sigmoid", "tanh"),
  lambda = 1,
  point_of_inference = c("peak", "final"),
  max_iter = 100,
  min_error = 1e-05,
  parallel = TRUE,
  n_cores = integer(),
  show_progress = TRUE,
  mc_sims_in_output = FALSE
)
}
\arguments{
\item{adj_matrices}{A list of adjecency matrices}

\item{initial_state_vector}{A list state values at the start of an fcm simulation}

\item{clamping_vector}{A list of values representing specific actions taken to
control the behavior of an FCM. Specifically, non-zero values defined in this vector
will remain constant throughout the entire simulation as if they were "clamped" at those values.}

\item{activation}{The activation function to be applied. Must be one of the following:
'kosko', 'modified-kosko', or 'papageorgiou'.}

\item{squashing}{A squashing function to apply. Must be one of the following:
'bivalent', 'saturation', 'trivalent', 'tanh', or 'sigmoid'.}

\item{lambda}{A numeric value that defines the steepness of the slope of the
squashing function when tanh or sigmoid are applied}

\item{point_of_inference}{The point along the simulation time-series to be
identified as the inference. Must be one of the following: 'peak' or 'final'}

\item{max_iter}{The maximum number of iterations to run if the minimum error value is not achieved}

\item{min_error}{The lowest error (sum of the absolute value of the current state
vector minus the previous state vector) at which no more iterations are necessary
and the simulation will stop}

\item{parallel}{TRUE/FALSE Whether to utilize parallel processing}

\item{n_cores}{Number of cores to use in parallel processing. If no input given,
will use all available cores in the machine.}

\item{show_progress}{TRUE/FALSE Show progress bar when creating fmcm. Uses pbmapply
from the pbapply package as the underlying function.}

\item{mc_sims_in_output}{TRUE/FALSE whether to include simulations of monte-carlo-generated
FCM. Will dramatically increase size of output if TRUE.}
}
\value{
NULL; Errors if checks fail
}
\description{
Check inputs for running infer_fcm on a list of adj. matrices
}
\examples{
NULL
}
\seealso{
Other monte-carlo-model-generation-and-simulation: 
\code{\link{build_monte_carlo_fcms}()},
\code{\link{build_monte_carlo_fcms_from_conventional_adj_matrices}()},
\code{\link{build_monte_carlo_fcms_from_fuzzy_set_adj_matrices}()},
\code{\link{check_build_monte_carlo_fcms_inputs}()},
\code{\link{check_monte_carlo_bootstrap_inputs}()},
\code{\link{get_mc_simulations_inference_CIs_w_bootstrap}()},
\code{\link{infer_fcm_set}()}
}
\concept{monte-carlo-model-generation-and-simulation}
\keyword{internal}
