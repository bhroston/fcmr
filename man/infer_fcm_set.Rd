% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/infer_and_simulate_fcm.R
\name{infer_fcm_set}
\alias{infer_fcm_set}
\title{Infer FCMs Generated from Monte Carlo Methods}
\usage{
infer_fcm_set(
  adj_matrices = list(matrix()),
  initial_state_vector = c(),
  clamping_vector = c(),
  activation = c("kosko", "modified-kosko", "rescale"),
  squashing = c("sigmoid", "tanh"),
  lambda = 1,
  point_of_inference = c("peak", "final"),
  max_iter = 100,
  min_error = 1e-05,
  parallel = TRUE,
  n_cores = integer(),
  show_progress = TRUE,
  mc_sims_in_output = FALSE
)
}
\arguments{
\item{adj_matrices}{A list of adjecency matrices generated from simulation using build_fmcm_models.}

\item{initial_state_vector}{A list state values at the start of an fcm simulation}

\item{clamping_vector}{A list of values representing specific actions taken to
control the behavior of an FCM. Specifically, non-zero values defined in this vector
will remain constant throughout the entire simulation as if they were "clamped" at those values.}

\item{activation}{The activation function to be applied. Must be one of the following:
'kosko', 'modified-kosko', or 'papageorgiou'.}

\item{squashing}{A squashing function to apply. Must be one of the following:
'bivalent', 'saturation', 'trivalent', 'tanh', or 'sigmoid'.}

\item{lambda}{A numeric value that defines the steepness of the slope of the
squashing function when tanh or sigmoid are applied}

\item{point_of_inference}{The point along the simulation time-series to be
identified as the inference. Must be one of the following: 'peak' or 'final'}

\item{max_iter}{The maximum number of iterations to run if the minimum error value is not achieved}

\item{min_error}{The lowest error (sum of the absolute value of the current state
vector minus the previous state vector) at which no more iterations are necessary
and the simulation will stop}

\item{parallel}{TRUE/FALSE Whether to utilize parallel processing}

\item{n_cores}{Number of cores to use in parallel processing. If no input given,
will use all available cores in the machine.}

\item{show_progress}{TRUE/FALSE Show progress bar when creating fmcm. Uses pbmapply
from the pbapply package as the underlying function.}

\item{mc_sims_in_output}{TRUE/FALSE whether to include simulations of monte-carlo-generated
FCM. Will dramatically increase size of output if TRUE.}
}
\value{
A list of two dataframes: the first contains all inference estimates
across the empirical (monte carlo) FCM inferences, and the second is an
elongated version of the first dataframe that organizes the data for
plotting (particularly with ggplot2)
}
\description{
This function mass simulates a set of FCMs (Conventional, IVFN, and/or TFN)
(whose edge weights were sampled using monte carlo methods) by repetitively
calling the infer_fcm function for each empirical (monte carlo) adj. matrix.
}
\details{
The show_progress and parallel inputs change the functions called, but do NOT
change the output! These are allowed to be toggled on/off to increase user
control at runtime.
}
\examples{
ex_adj_matrix_1 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0, 0, 0, 1),
  "C" = c(0, 1, 0, 0),
  "D" = c(0, 0, 1, 0)
)
ex_adj_matrix_2 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0.25, 0, 0, 0.25),
  "C" = c(0, 0.25, 0, 0),
  "D" = c(0, 0, 0.25, 0)
)
ex_adj_matrix_3 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0.75, 0, 0, 0.75),
  "C" = c(0, 0.75, 0, 0),
  "D" = c(0, 0, 0.75, 0)
)
ex_adj_matrix_4 <- data.frame(
  "A" = c(0, 0, 0, 0),
  "B" = c(0.5, 0, 0, 0.5),
  "C" = c(0, 0.5, 0, 0),
  "D" = c(0, 0, 0.5, 0)
)
ex_fcms <- list(
  ex_adj_matrix_1, ex_adj_matrix_2, ex_adj_matrix_3, ex_adj_matrix_4
)

mc_fcms <- build_monte_carlo_fcms_from_conventional_adj_matrices(
  ex_fcms, N_samples = 1000, include_zeroes = FALSE, show_progress = TRUE
)

mc_fcms_inferences <- infer_fcm_set(
  adj_matrices = mc_fcms,
  initial_state_vector <- c(1, 1, 1, 1),
  clamping_vector <- c(1, 0, 0, 0),
  activation = "kosko",
  squashing = "sigmoid",
  lambda = 1,
  point_of_inference = "final",
  max_iter = 1000,
  min_error = 1e-5,
  parallel = FALSE,
  show_progress = TRUE
)




# For Interval-Valued Fuzzy Numbers (IVFNs)
lower_adj_matrix_1 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.4, 0)
)
upper_adj_matrix_1 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.6, 0)
)
adj_matrix_1 <- make_adj_matrix_w_ivfns(lower_adj_matrix_1, upper_adj_matrix_1)
lower_adj_matrix_2 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.6, 0)
)
upper_adj_matrix_2 <- data.frame(
  "A" = c(0, 0),
  "B" = c(1, 0)
)
adj_matrix_2 <- make_adj_matrix_w_ivfns(lower_adj_matrix_2, upper_adj_matrix_2)
lower_adj_matrix_3 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.2, 0)
)
upper_adj_matrix_3 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.6, 0)
)
adj_matrix_3 <- make_adj_matrix_w_ivfns(lower_adj_matrix_3, upper_adj_matrix_3)
lower_adj_matrix_4 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.0, 0)
)
upper_adj_matrix_4 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.4, 0)
)
adj_matrix_4 <- make_adj_matrix_w_ivfns(lower_adj_matrix_4, upper_adj_matrix_4)
fcms_w_ivfns <- list(adj_matrix_1, adj_matrix_2, adj_matrix_3, adj_matrix_4)

mc_fcms <- build_monte_carlo_fcms_from_fuzzy_set_adj_matrices(
  fcms_w_ivfns, "ivfn", 1000, include_zeroes = FALSE
)
mc_fcms_inferences <- infer_fcm_set(
  adj_matrices = mc_fcms,
  initial_state_vector <- c(1, 1),
  clamping_vector <- c(1, 0),
  activation = "kosko",
  squashing = "sigmoid",
  lambda = 1,
  point_of_inference = "final",
  max_iter = 100,
  min_error = 1e-5,
  parallel = FALSE,
  show_progress = TRUE
)

# For Triangular Fuzzy Numbers (TFNs)
lower_adj_matrix_1 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.4, 0)
)
mode_adj_matrix_1 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.4, 0)
)
upper_adj_matrix_1 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.6, 0)
)
adj_matrix_1 <- make_adj_matrix_w_tfns(
  lower_adj_matrix_1, mode_adj_matrix_1, upper_adj_matrix_1
)
lower_adj_matrix_2 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.6, 0)
)
mode_adj_matrix_2 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.7, 0)
)
upper_adj_matrix_2 <- data.frame(
  "A" = c(0, 0),
  "B" = c(1, 0)
)
adj_matrix_2 <- make_adj_matrix_w_tfns(
  lower_adj_matrix_2, mode_adj_matrix_2, upper_adj_matrix_2
)
lower_adj_matrix_3 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.2, 0)
)
mode_adj_matrix_3 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.4, 0)
)
upper_adj_matrix_3 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.6, 0)
)
adj_matrix_3 <- make_adj_matrix_w_tfns(
  lower_adj_matrix_3, mode_adj_matrix_3, upper_adj_matrix_3
)
lower_adj_matrix_4 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.0, 0)
)
mode_adj_matrix_4 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0, 0)
)
upper_adj_matrix_4 <- data.frame(
  "A" = c(0, 0),
  "B" = c(0.4, 0)
)
adj_matrix_4 <- make_adj_matrix_w_tfns(
  lower_adj_matrix_4, mode_adj_matrix_4, upper_adj_matrix_4
)

fcms_w_tfns <- list(adj_matrix_1, adj_matrix_2, adj_matrix_3, adj_matrix_4)

mc_fcms <- build_monte_carlo_fcms_from_fuzzy_set_adj_matrices(
  fcms_w_tfns, "tfn", 1000, include_zeroes = FALSE
)
mc_fcms_inferences <- infer_fcm_set(
  adj_matrices = mc_fcms,
  initial_state_vector <- c(1, 1),
  clamping_vector <- c(1, 0),
  activation = "kosko",
  squashing = "sigmoid",
  lambda = 1,
  point_of_inference = "final",
  max_iter = 100,
  min_error = 1e-5,
  parallel = FALSE,
  show_progress = TRUE
)
}
\seealso{
Other monte-carlo-model-generation-and-simulation: 
\code{\link{build_monte_carlo_fcms}()},
\code{\link{build_monte_carlo_fcms_from_conventional_adj_matrices}()},
\code{\link{build_monte_carlo_fcms_from_fuzzy_set_adj_matrices}()},
\code{\link{check_build_monte_carlo_fcms_inputs}()},
\code{\link{check_infer_fcm_set_inputs}()},
\code{\link{check_monte_carlo_bootstrap_inputs}()},
\code{\link{get_mc_simulations_inference_CIs_w_bootstrap}()}
}
\concept{monte-carlo-model-generation-and-simulation}
