% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/infer_and_simulate_fcm.R
\name{infer_ivfn_or_tfn_fcm}
\alias{infer_ivfn_or_tfn_fcm}
\title{Infer (IVFN or TFN) FCM}
\usage{
infer_ivfn_or_tfn_fcm(
  adj_matrix = matrix(),
  initial_state_vector = c(),
  clamping_vector = c(),
  activation = "kosko",
  squashing = "tanh",
  lambda = 1,
  max_iter = 100,
  min_error = 1e-05
)
}
\arguments{
\item{adj_matrix}{An n x n adjacency matrix that represents an FCM}

\item{initial_state_vector}{A list state values at the start of an fcm simulation}

\item{clamping_vector}{A list of values representing specific actions taken to
control the behavior of an FCM. Specifically, non-zero values defined in this vector
will remain constant throughout the entire simulation as if they were "clamped" at those values.}

\item{activation}{The activation function to be applied. Must be one of the following:
'kosko', 'modified-kosko', or 'rescale'.}

\item{squashing}{A squashing function to apply. Must be one of the following:
'bivalent', 'saturation', 'trivalent', 'tanh', or 'sigmoid'.}

\item{lambda}{A numeric value that defines the steepness of the slope of the
squashing function when tanh or sigmoid are applied}

\item{max_iter}{The maximum number of iterations to run if the minimum error value is not achieved}

\item{min_error}{The lowest error (sum of the absolute value of the current state
vector minus the previous state vector) at which no more iterations are necessary
and the simulation will stop}
}
\value{
A list of (ivfn or tfn) fcm inference results (including baseline
and simulation outputs)
}
\description{
This compares the baseline simulation of an fcm with the input scenario (scenario vector)
to estimate how outputs change compared to the structural or expected behavior
of the system.
}
\details{
This function performs two fcm simulations and compares the output between the two.
The first simulation considers the baseline activity where no nodes are "clamped" and the
system behaves without any outside inputs. The second simulation considers a scenario where
one or multiple nodes are "clamped" so that the system is reactive to additional inputs.
The function returns the difference in simulation results between the scenario and baseline
activity to understand how system manipulations compare to structural expectations of the system.

This function produces the same output as mental modeler for the following inputs:
 - initial_state_vector = c(1, 1, ..., 1)
 - activation = "kosko"
 - squashing = either "sigmoid" or "tanh"
 - lambda = 1
}
\examples{
# Inference w/ Interval-Valued Fuzzy Numbers (IVFNs)
lower_adj_matrix <- data.frame(
  C1 = c(0, 0, 0, 0, 0, 0),
  C2 = c(-0.85, 0, 0, 0.35, 0, 0),
  C3 = c(0, 0, 0, 0, 0, 0),
  C4 = c(-0.7, 0.6, -1, 0, -1, 0),
  C5 = c(0.1, 0, 0, -0.8, 0, 0),
  C6 = c(0, -0.95, 0, 0, -0.95, 0)
)
upper_adj_matrix <- data.frame(
  C1 = c(0, 0, 0, 0, 0, 0),
  C2 = c(-0.2, 0, 0, 0.9, 0, 0),
  C3 = c(0, 0, 0, 0, 0, 0),
  C4 = c(-0.3, 0.9, -0.5, 0, -0.5, 0),
  C5 = c(0.5, 0, 0, -0.3, 0, 0),
  C6 = c(0, -0.4, 0, 0, -0.5, 0)
)
adj_matrix <- make_adj_matrix_w_ivfns(lower_adj_matrix, upper_adj_matrix)

infer_fcm(adj_matrix,
          initial_state_vector = c(1, 1, 1, 1, 1, 1),
          clamping_vector = c(1, 0, 0, 0, 0, 0),
          activation = "kosko",
          squashing = "sigmoid",
          lambda = 1)


# Inference w/ Triangular Fuzzy Numbers (TFNs)
lower_adj_matrix <- data.frame(
  C1 = c(0, 0, 0, 0, 0, 0),
  C2 = c(-0.85, 0, 0, 0.35, 0, 0),
  C3 = c(0, 0, 0, 0, 0, 0),
  C4 = c(-0.7, 0.6, -1, 0, -1, 0),
  C5 = c(0.1, 0, 0, -0.8, 0, 0),
  C6 = c(0, -0.95, 0, 0, -0.95, 0)
)
mode_adj_matrix <- data.frame(
  C1 = c(0, 0, 0, 0, 0, 0),
  C2 = c(-0.5, 0, 0, 0.6, 0, 0),
  C3 = c(0, 0, 0, 0, 0, 0),
  C4 = c(-0.5, 0.7, -0.8, 0, -0.8, 0),
  C5 = c(0.2, 0, 0, -0.6, 0, 0),
  C6 = c(0, -0.7, 0, 0, -0.6, 0)
)
upper_adj_matrix <- data.frame(
  C1 = c(0, 0, 0, 0, 0, 0),
  C2 = c(-0.2, 0, 0, 0.9, 0, 0),
  C3 = c(0, 0, 0, 0, 0, 0),
  C4 = c(-0.3, 0.9, -0.5, 0, -0.5, 0),
  C5 = c(0.5, 0, 0, -0.3, 0, 0),
  C6 = c(0, -0.4, 0, 0, -0.5, 0)
)
adj_matrix <- make_adj_matrix_w_tfns(lower_adj_matrix, mode_adj_matrix, upper_adj_matrix)

infer_fcm(adj_matrix,
          initial_state_vector = c(1, 1, 1, 1, 1, 1),
          clamping_vector = c(1, 0, 0, 0, 0, 0),
          activation = "kosko",
          squashing = "sigmoid",
          lambda = 1)
}
