% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fcmconfr.R
\name{check_fcmconfr_inputs}
\alias{check_fcmconfr_inputs}
\title{[INTENDED FOR DEVELOPER USE ONLY] Check fcmconfr Inputs}
\usage{
check_fcmconfr_inputs(
  adj_matrices = list(matrix()),
  agg_function = c("mean", "median"),
  num_mc_fcms = 1000,
  initial_state_vector = c(),
  clamping_vector = c(),
  activation = c("kosko", "modified-kosko", "rescale"),
  squashing = c("sigmoid", "tanh", "bivalent", "saturation", "trivalent"),
  lambda = 1,
  point_of_inference = c("peak", "final"),
  max_iter = 100,
  min_error = 1e-05,
  ci_centering_function = c("mean", "median"),
  confidence_interval = 0.95,
  num_ci_bootstraps = 5000,
  show_progress = TRUE,
  parallel = TRUE,
  n_cores = integer(),
  run_agg_calcs = TRUE,
  run_mc_calcs = TRUE,
  run_ci_calcs = TRUE,
  include_zeroes_in_sampling = FALSE,
  mc_sims_in_output = TRUE
)
}
\arguments{
\item{adj_matrices}{A list of adjacency matrices (n x n) representing FCMs. This
can also be an individual adjacency matrix.Adj. Matrices can be conventional FCMs,
FCMs with edge weights as Interval Value Fuzzy Numbers (IVFNs) or FCMs with edge
weights as Triangular Fuzzy Numbers (TFNs)}

\item{agg_function}{Aggregate the adj. matrices into a single FCM by taking
either the mean or median of the edge weights for edges included in multiple maps}

\item{num_mc_fcms}{The number of FCMs to generate via monte carlo
sampling from the input adj. matrices}

\item{initial_state_vector}{A list state values at the start of an fcm simulation}

\item{clamping_vector}{A list of values representing specific actions taken to
control the behavior of an FCM. Specifically, non-zero values defined in this vector
will remain constant throughout the entire simulation as if they were "clamped" at those values.}

\item{activation}{The activation function to be applied. Must be one of the following:
'kosko', 'modified-kosko', or 'papageorgiou'.}

\item{squashing}{A squashing function to apply. Must be one of the following:
'bivalent', 'saturation', 'trivalent', 'tanh', or 'sigmoid'.}

\item{lambda}{A numeric value that defines the steepness of the slope of the
squashing function when tanh or sigmoid are applied}

\item{point_of_inference}{The point along the simulation time-series to be
identified as the inference. Must be one of the following: 'peak' or 'final'}

\item{max_iter}{The maximum number of iterations to run if the minimum error value is not achieved}

\item{min_error}{The lowest error (sum of the absolute value of the current state
vector minus the previous state vector) at which no more iterations are necessary
and the simulation will stop}

\item{ci_centering_function}{Estimate confidence intervals about the "mean" or "median" of
inferences from the monte carlo simulations}

\item{confidence_interval}{The confidence interval to estimate for the inferences
of each concept across all monte carlo FCMs (via bootstrap)}

\item{num_ci_bootstraps}{The number of bootstraps to perform in
estimating the confidence interval for the inferences of each concept across all monte
carlo FCMs}

\item{show_progress}{TRUE/FALSE Show progress bar when creating fmcm. Uses pbmapply
from the pbapply package as the underlying function.}

\item{parallel}{TRUE/FALSE Whether to utilize parallel processing}

\item{n_cores}{Number of cores to use in parallel processing. If no input given,
will use all available cores in the machine.}

\item{run_agg_calcs}{TRUE/FALSE Run the code to generate and simulate an aggregate FCM generated from the input adj_matrices}

\item{run_mc_calcs}{TRUE/FALSE Run the code to generate and simulate monte carlo-generated FCM sampled from the input adj_matrices}

\item{run_ci_calcs}{TRUE/FALSE Run the code to estimate the 95 percent CI bounds about the means of the inferences of the monte carlo adj matrices}

\item{include_zeroes_in_sampling}{TRUE/FALSE Whether to incorporate zeroes as intentionally-defined edge weights or ignore
them when aggregating adj. matrices and sampling for monte carlo FCMs}

\item{mc_sims_in_output}{TRUE/FALSE Whether to include simulations of monte carlo FCMs. Switch to FALSE if concerned
about the size of the output of fcmconfr (simulations are necessary and will run regardless)}
}
\value{
A list of resolved inputs to pass to \code{\link{fcmconfr}}
}
\description{
Confirm that all inputs will work with the \code{\link{fcmconfr}} function and return
appropriate error messages where necessary
}
\details{
INTENDED FOR DEVELOPER USE ONLY

This checks that all inputs for the \code{\link{fcmconfr}} function are of an appropriate
format, and also fills in missing inputs for initial_state_vector, clamping_vector,
and IDs when appropriate.
}
\examples{
NULL
}
