<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>fcmconfr • fcmconfr</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="fcmconfr">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">fcmconfr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/fcmconfr.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/fcmconfr_example.html">fcmconfr_Example</a></li>
    <li><a class="dropdown-item" href="../articles/Importing_FCMs.html">Importing_FCMs</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/bhroston/fcmconfr/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>fcmconfr</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/bhroston/fcmconfr/blob/main/vignettes/fcmconfr.Rmd" class="external-link"><code>vignettes/fcmconfr.Rmd</code></a></small>
      <div class="d-none name"><code>fcmconfr.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/bhroston/fcmconfr" class="external-link">fcmconfr</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="the-fcmconfr-workflow">The <code>fcmconfr</code> Workflow<a class="anchor" aria-label="anchor" href="#the-fcmconfr-workflow"></a>
</h2>
<p><code>fcmconfr</code> streamlines the process of conducting dynamic
simulations using fuzzy cognitive maps (FCMs). The package can (1)
analyze different types of FCMs (conventional, interval-value fuzzy
number, and triangular fuzzy number), (2) perform dynamic simulations on
one or more individual FCMs, (3) aggregate individual FCMs so that
dynamic simulations can be performed on the aggregate, and (4) estimate
uncertainty using Monte Carlo approaches. A typical fcmconfer workflow
includes the following four steps:</p>
<ol style="list-style-type: decimal">
<li><p>Import FCMs</p></li>
<li><p>Set simulation parameters using
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code></p></li>
<li><p>Run simulations using <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code></p></li>
<li><p>Explore outputs using <code><a href="../reference/get_inferences.html">get_inferences()</a></code> and
<code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code></p></li>
</ol>
<p>This guide walks through each of these steps, from data import to
visualization. It frequently references data from a
<code>sample_fcms</code> object that users can access after loading
<code>fcmconfr</code>.</p>
<div class="section level3">
<h3 id="import-fcms">1. Import FCMs<a class="anchor" aria-label="anchor" href="#import-fcms"></a>
</h3>
<p><code>fcmconfr</code> can handle three different types of FCMs: (1)
conventional, where each edge weight is represented using numeric
values, (2) interval-value fuzzy number FCMs (IVFN-FCMs), where each
edge weight is represented using two numeric values (lower bound, upper
bound; i.e., an IVFN), and (3) triangular fuzzy number FCMs (TFN-FCMs),
where each edge weight is represented using three numeric values (lower
bound, mode, upper bound; i.e., a TFN).</p>
<p><em>A detailed guide for importing each FCM type in a manner
compatible with <code>fcmconfr</code> has been provided in a separate,
companion vignette (Importing_FCMs; run
<code><a href="../articles/Importing_FCMs.html">vignette("Importing_FCMs", package = 'fcmconfr')</a></code> to view).
A brief description of the typical workflow used to import each FCM type
has been provided below.</em></p>
<div class="section level4">
<h4 id="importing-conventional-fcms">1.1 Importing Conventional FCMs<a class="anchor" aria-label="anchor" href="#importing-conventional-fcms"></a>
</h4>
<p>Conventional FCMs can be imported as adjacency matrices, either from
excel or csv files using standard import functions (e.g., calls to
<code>readxl::read_excel()</code> or <code><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv()</a></code>). Users who
plan to use <code>fcmconfr</code> to analyze multiple FCMs together
should group them into a single <code>list</code> object.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Import Conventional FCMs into the Global Environment</span></span>
<span><span class="va">fcm_1</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">fcm_1_filepath</span><span class="op">)</span></span>
<span><span class="va">fcm_2</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">fcm_2_filepath</span><span class="op">)</span></span>
<span><span class="va">...</span></span>
<span><span class="va">fcm_n</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">fcm_n_filepath</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Group them together in a single list object</span></span>
<span><span class="va">fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">fcm_1</span>, <span class="va">fcm_2</span>, <span class="va">...</span>, <span class="va">fcm_n</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="importing-ivfn-fcms">1.2 Importing IVFN FCMs<a class="anchor" aria-label="anchor" href="#importing-ivfn-fcms"></a>
</h4>
<p>Because IVFN-FCMs have interval edge weights with lower and upper
bounds, separate adjacency matrices must be created and uploaded for
each bound (lower and upper). We can then use the function
<code><a href="../reference/make_adj_matrix_w_ivfns.html">make_adj_matrix_w_ivfns()</a></code> to combine the two, creating a
single adjacency matrix with interval edge weights. As noted previously
for conventional FCMs, users who plan to analyze multiple IVFN FCMs
together should group them into a single list object.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Import separate adjacency matrices representing the </span></span>
<span><span class="co"># lower and upper bounds of each edge weight</span></span>
<span><span class="va">ivfn_fcm_1_lower_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_lower_adj_matrix_filepath</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm_1_upper_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_upper_adj_matrix_filepath</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine the lower and upper adjacency matrices to make an IVFN FCM</span></span>
<span><span class="va">ivfn_fcm_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_adj_matrix_w_ivfns.html">make_adj_matrix_w_ivfns</a></span><span class="op">(</span></span>
<span>  <span class="va">ivfn_fcm_1_lower_adj_matrix</span>, <span class="va">ivfn_fcm_1_upper_adj_matrix</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Group multiple IVFN-FCMs together in a single list object</span></span>
<span><span class="va">ivfn_fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">ivfn_fcm_1</span>, <span class="va">ivfn_fcm_2</span>, <span class="va">...</span>, <span class="va">ivfn_fcm_n</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="importing-tfn-fcms">1.3 Importing TFN FCMs<a class="anchor" aria-label="anchor" href="#importing-tfn-fcms"></a>
</h4>
<p>The workflow for importing TFN FCMs is comparable to the workflow for
IVFN FCMs. The main differences are (1) the need to upload three
adjacency matrices rather than two (one for the lower bound, one for the
mode, and one for the upper bound) and (2) the function call to combine
these matrices, which is <code><a href="../reference/make_adj_matrix_w_tfns.html">make_adj_matrix_w_tfns()</a></code> rather
than <code><a href="../reference/make_adj_matrix_w_ivfns.html">make_adj_matrix_w_ivfns()</a></code>). Users who plan to analyze
multiple TFN-FCMs together should group them into a single
<code>list</code> object.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Import separate adjacency matrices representing the </span></span>
<span><span class="co"># lower and upper bounds as well as the mode  of each edge weight</span></span>
<span><span class="va">ivfn_fcm_1_lower_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_lower_adj_matrix_filepath</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm_1_mode_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_mode_adj_matrix_filepath</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm_1_upper_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_upper_adj_matrix_filepath</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine the lower and upper adjacency matrices to make a TFN-FCM</span></span>
<span><span class="va">tfn_fcm_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_adj_matrix_w_tfns.html">make_adj_matrix_w_tfns</a></span><span class="op">(</span></span>
<span>  <span class="va">tfn_fcm_1_lower_adj_matrix</span>, <span class="va">tfn_fcm_1_mode_adj_matrix</span>, <span class="va">tfn_fcm_1_upper_adj_matrix</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Group multiple TFN-FCMs together in a single list object</span></span>
<span><span class="va">tfn_fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">tfn_fcm_1</span>, <span class="va">tfn_fcm_2</span>, <span class="va">...</span>, <span class="va">tfn_fcm_n</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="interacting-with-ivfn-and-tfn-adjacency-matrix-elements">1.4 Interacting with IVFN and TFN Adjacency Matrix Elements<a class="anchor" aria-label="anchor" href="#interacting-with-ivfn-and-tfn-adjacency-matrix-elements"></a>
</h4>
<p>Since users can make IVFN or TFN adjacency matrices by importing
matrices from files, they will rarely have to create an IVFN or TFN
matrix from scratch. However, the example below illustrates how
<code>fcmconfr</code> creates such objects. The example we provide below
is for an IVFN matrix. The approach for a TFN matrix is similar, but
uses three- rather than two-element lists.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># First, create a dataframe from a n x n matrix of lists</span></span>
<span><span class="va">ivfn_fcm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Then, place the ivfn/tfn within a list and define its location indices</span></span>
<span><span class="co"># Note that since ivfn_df is a matrix of lists, we define the new </span></span>
<span><span class="co"># ivfn object as the first element of the list at index [1, 2], hence the</span></span>
<span><span class="co"># need for [[1]] at the end.</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">0.6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0.7</span>, <span class="fl">0.8</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Fivfn_df_formats.png" style="width:70.0%" alt="ivfn_df formats. The console output for ivfn_fcm will vary depending on whether it is loaded as a matrix or dataframe. As a dataframe it will print out the IVFN values, while as a matrix it will print out the object types, ivfn, 2. These differences do not impact the way we interact with ivfn_fcm."><div class="figcaption">
<code>ivfn_df</code> formats. The console output
for <code>ivfn_fcm</code> will vary depending on whether it is loaded as
a matrix or dataframe. As a dataframe it will print out the IVFN values,
while as a matrix it will print out the object types,
<code>ivfn, 2</code>. These differences do not impact the way we
interact with <code>ivfn_fcm</code>.</div>
</div>
</div>
<p><br></p>
<p>To report the IVFN of a particular edge within an IVFN matrix, we can
call <code>ivfn_fcm[row, col]</code>, which returns a <code>list</code>
object or <code>ivfn_fcm[row, col][[1]]</code> to return the first
record in the <code>list</code> object, the IVFN itself.</p>
<div style="text-align: center;">
<p><img src="images%2Fivfn_example.png" style="width:50.0%"></p>
</div>
<p><br></p>
<p>To decompose an IVFN matrix into its upper and lower bounds, we can
do the following:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lower_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">ivfn_df</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="kw">function</span><span class="op">(</span><span class="va">element</span><span class="op">)</span> <span class="va">element</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">lower</span><span class="op">)</span></span>
<span><span class="va">upper_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">ivfn_df</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="kw">function</span><span class="op">(</span><span class="va">element</span><span class="op">)</span> <span class="va">element</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">upper</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="viewing-imported-fcms">1.5 Viewing Imported FCMs<a class="anchor" aria-label="anchor" href="#viewing-imported-fcms"></a>
</h4>
<p>Users may display FCMs in RStudio’s Viewer pane using
<code><a href="../reference/fcm_view.html">fcm_view()</a></code>, which plots an FCM (adjacency matrix) as a
<code>visNetwork</code> object. The resulting plot is interactive. Users
can manipulate node positions (i.e. node layout) to explore the FCM from
different angles. The function can be used with any of the three FCM
types recognized by <code>fcmconfr</code>. For IVFN and TFN-FCMs,
<code><a href="../reference/fcm_view.html">fcm_view()</a></code> plots the average edge weight to simplify the
output.</p>
<p>Two basic applications of <code><a href="../reference/fcm_view.html">fcm_view()</a></code> are illustrated
below, one that plots the FCM in the Viewer pane and one that plots the
FCM in a separate Shiny App.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Loading FCM from sample_fcms data</span></span>
<span><span class="va">adj_matrix</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">conventional_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Show FCM in Viewer Pane</span></span>
<span><span class="fu"><a href="../reference/fcm_view.html">fcm_view</a></span><span class="op">(</span>fcm_adj_matrix <span class="op">=</span> <span class="va">adj_matrix</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Show FCM in Separate Shiny App (returns a visNetwork object in the Global Environment)</span></span>
<span><span class="fu"><a href="../reference/fcm_view.html">fcm_view</a></span><span class="op">(</span>fcm_adj_matrix <span class="op">=</span> <span class="va">adj_matrix</span>, with_shiny <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ffcm_view_output.png" style="width:80.0%" alt="visNetwork Output of fcm_view. Drag nodes to rearrange layout."><div class="figcaption">visNetwork Output of fcm_view. Drag nodes to
rearrange layout.</div>
</div>
</div>
<p><code><a href="../reference/fcm_view.html">fcm_view()</a></code> has an additional argument
<code>with_shiny</code> (default <code>= FALSE</code>). If set to TRUE,
<code><a href="../reference/fcm_view.html">fcm_view()</a></code> records the <code>visNetwork</code> output in
the Global Environment as <code>view_fcm_visNetwork_output</code>. This
output stores node coordinates so nodes can be plotted in the same
position if manipulated by the user and can be interacted with as a
typical <code>visNetwork</code> object for users interested in
additional customization.</p>
<p>Note: At its core, <code><a href="../reference/fcm_view.html">fcm_view()</a></code> is just a call to
<code>visNetwork</code> functions. Users who have experience with
<code>visNetwork</code> should feel free to plot FCMs directly with
<code>visNetwork</code> for greater flexibility.</p>
</div>
</div>
<div class="section level3">
<h3 id="set-simulation-parameters-using-fcmconfr_gui">2. Set Simulation Parameters using <code>fcmconfr_gui()</code><a class="anchor" aria-label="anchor" href="#set-simulation-parameters-using-fcmconfr_gui"></a>
</h3>
<p>The primary <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> function is the central function
of the package and requires specifying many different parameters. The
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> function is intended to help guide users
through that process.</p>
<p><code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> performs two tasks: (1) it launches a
Shiny app that lets users interactively select parameters and (2) it
outputs a corresponding call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> that users can
copy-and-paste to run in their own scripts.</p>
<p>No inputs are provided to <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code>, but the local
environment must have an individual FCM or a <code>list</code> object
containing multiple FCMs in order for <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> to be
used. Once <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> is running the user selects the
appropriate FCMs to analyze from a dropdown menu titled Adj. Matrix or
List of Adj. Matrices.</p>
<p>Matrices conforming to any of the above-noted FCM types
(conventional, IVFN, or TFN) can be selected for analysis.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/fcmconfr_gui.html">fcmconfr_gui</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ffcmconfr_gui_screenshot.png" style="width:90.0%" alt="A screenshot of fcmconfr_gui() with an example list of FCMs selected in the dropdown menu."><div class="figcaption">A screenshot of <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> with
an example list of FCMs selected in the dropdown menu.</div>
</div>
</div>
<p>The GUI interface is organized into four tabs: Data, Agg. and Monte
Carlo Options, Simulation Options, and Runtime Options, which are
described further below.</p>
<ul>
<li>
<p>Data: The Data tab is where the user selects the FCMs they want
to analyze (drop-down menu titled Adj. Matrix or List of Adj. Matrices).
It is also where they manipulate values in the Initial State (Pulse)
Vector or Clamping Vector to identify the dynamic simulations they wish
to explore.</p>
<p><em>(Note: It is best practice to set every value in the Initial
State (Pulse) Vector to 1 and to set only the node(s)-of-interest to 1
in the Clamping Vector. In this configuration, the Initial State (Pulse)
Vector is used to determine the network’s state at equilibrium and the
clamping vector is used to determine the network’s state in response to
continuous activation of one or more nodes. The difference between the
two is a measure of the impact of those particular nodes on the
system.)</em></p>
</li>
<li>
<p>Agg. and Monte Carlo Options: The Agg. and Monte Carlo Options
tab is where the user specifies their preferences regarding FCM
aggregation and Monte Carlo sampling. Aggregation options are only
available when datasets contain multiple FCMs. Monte Carlo sampling is
available for <code>list</code> objects of conventiona, IVFN- and
TFN-FCMs as well as individual IVFN-/TFN-FCMs, but not individual
conventional FCMs. Aggregation and Monte Carlo options can be toggled
off to speed up the simulation process.</p>
<ul>
<li><p>Aggregation options allow the user to specify whether multiple
FCMs should be aggregated into a single collective model so that dynamic
simulations can be performed on the aggregate in addition to individual
FCMs. The user can specify the aggregation method (mean or median) and
whether zero-weighted edges should be included in the aggregation
process.</p></li>
<li><p>Monte Carlo options allow the user to specify whether Monte Carlo
sampling should be performed to estimate uncertainty in dynamic
simulation outputs. If yes, the user must specify the number of FCMs
that will be generated by Monte Carlo sampling (we recommend 1000 or
more). Dynamic simulations will be performed on each of these FCMs,
providing a range of inferences for each node, from which the median
state and quantiles (25<sup>th</sup>, 75<sup>th</sup>) will be
estimated. The user also has the option to perform nonparametric
bootstrapping to estimate confidence bounds about the average inference
for each node. Confidence limits are user-specified (i.e.,
95<sup>th</sup> percentile, 90<sup>th</sup> percentile, etc.).</p></li>
</ul>
</li>
<li><p>Simulation Options: The Simulation Options tab is where users
specify the type of dynamic simulation to perform. This includes
specifying (1) the activation function (Kosko, Modified-Kosko, or
Rescale; default of Kosko), (2) the squashing function (sigmoid or
hyperbolic tangent; default of sigmoid), (3) the squashing function’s
key parameter, lambda (default of 1), (4) the final simulation output
(i.e., the peak estimate for each node or its final resting state;
default of final), (5) the maximum number of iterations to perform per
simulation (default of 100), and (6) the minimum acceptable error
between iterations (default of 1x10<sup>-5</sup>)</p></li>
<li><p>Runtime Options: The Runtime Options tab allows the user to
specify whether they want to use parallel processing and have a progress
bar displayed at runtime. These options do not impact the simulation
outputs. They do, however, influence how long <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>
takes to run and what the user sees at runtime.</p></li>
</ul>
<p>A brief summary of each parameter within the
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> is provided in a glossary stored in a side
tab within the GUI. The side tab can be opened by clicking the arrow
symbol in the top-right-hand-corner of the GUI.</p>
<p>Once parameter selection is complete, click the Submit button at the
bottom of the GUI to receive the corresponding code for a call to
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. This code will be reported in the console. DO
NOT exit the GUI without clicking Submit. Doing so WILL NOT create a
call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> and all previously entered information
will be lost. The following code is an example output from
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code>.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/fcmconfr.html">fcmconfr</a></span><span class="op">(</span></span>
<span>  adj_matrices <span class="op">=</span> <span class="va">sample_fcm_list</span>,</span>
<span>  <span class="co"># Aggregation and Monte Carlo Sampling</span></span>
<span>  agg_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  num_mc_fcms <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Simulation</span></span>
<span>  initial_state_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  clamping_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  activation <span class="op">=</span> <span class="st">'rescale'</span>,</span>
<span>  squashing <span class="op">=</span> <span class="st">'sigmoid'</span>,</span>
<span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  point_of_inference <span class="op">=</span> <span class="st">'final'</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  min_error <span class="op">=</span> <span class="fl">1e-05</span>,</span>
<span>  <span class="co"># Inference Estimation (bootstrap)</span></span>
<span>  ci_centering_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  confidence_interval <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  num_ci_bootstraps <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Runtime Options</span></span>
<span>  show_progress <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  n_cores <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  <span class="co"># Additional Options</span></span>
<span>  run_agg_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_mc_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_ci_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_zeroes_in_sampling <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  include_sims_in_output <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Once the call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> has been generated by the
GUI, copy-and-paste it into another file and define it as a variable
(see example below):</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fcmconfr_obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fcmconfr.html">fcmconfr</a></span><span class="op">(</span></span>
<span>  adj_matrices <span class="op">=</span> <span class="va">sample_fcm_list</span>,</span>
<span>  <span class="co"># Aggregation and Monte Carlo Sampling</span></span>
<span>  agg_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  num_mc_fcms <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Simulation</span></span>
<span>  initial_state_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  clamping_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  activation <span class="op">=</span> <span class="st">'rescale'</span>,</span>
<span>  squashing <span class="op">=</span> <span class="st">'sigmoid'</span>,</span>
<span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  point_of_inference <span class="op">=</span> <span class="st">'final'</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  min_error <span class="op">=</span> <span class="fl">1e-05</span>,</span>
<span>  <span class="co"># Inference Estimation (bootstrap)</span></span>
<span>  ci_centering_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  confidence_interval <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  num_ci_bootstraps <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Runtime Options</span></span>
<span>  show_progress <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  n_cores <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  <span class="co"># Additional Options</span></span>
<span>  run_agg_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_mc_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_ci_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_zeroes_in_sampling <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  include_sims_in_output <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="section level4">
<h4 id="optional-selecting-an-appropriate-lambda">Optional: Selecting an Appropriate Lambda<a class="anchor" aria-label="anchor" href="#optional-selecting-an-appropriate-lambda"></a>
</h4>
<p>Lambda is set to 1 by default in <code>fcmconfr</code>. However,
there is no one “correct” value for lambda and values that work for one
FCM may not work for another. To give users a starting estimate for
lambda, <code>fcmconfr</code> provides the
<code>estimate_lambda()</code> function, which implements an algorithm
developed by Koutsellis et al. (2022) - <a href="https://doi.org/10.1007/s12351-022-00717-x" class="external-link uri">https://doi.org/10.1007/s12351-022-00717-x</a>.</p>
<p><code>estimate_lambda()</code> returns the maximum lambda value that
guarantees simulation convergence (i.e. the max. usable value for
lambda) given a particular adjacency matrix and squashing function
(<code>sigmoid</code> or <code>tanh</code>).</p>
<p>An example call to <code>estimate_lambda()</code> has been provided
below.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">example_fcm</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">conventional_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="fu">estimate_lambda</span><span class="op">(</span><span class="va">example_fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span>
<span><span class="fu">estimate_lambda</span><span class="op">(</span><span class="va">example_fcm</span>, squashing <span class="op">=</span> <span class="st">"tanh"</span><span class="op">)</span></span></code></pre></div>
<p>The <a href="https://doi.org/10.1007/s12351-022-00717-x" class="external-link">Koutsellis
et al. (2022)</a> algorithm is intended for conventional FCMs. If an
IVFN-FCM or TFN-FCM is provided, <code>estimate_lambda()</code> will
create a conventional FCM by averaging the edge weights (upper and lower
for IVFN-FCMs and upper, mode, and lower for TFN-FCMs) for use in
calculating lambda.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">example_ivfn_fcm</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">ivfn_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">example_tfn_fcm</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">tfn_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="fu">estimate_lambda</span><span class="op">(</span><span class="va">example_ivfn_fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span>
<span><span class="fu">estimate_lambda</span><span class="op">(</span><span class="va">example_tfn_fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span></code></pre></div>
<p>It is important to note that <code>estimate_lambda()</code> returns a
<u>potential</u> lambda value, not a perfect lambda value, though values
less than the <code>estimate_lambda()</code> output are more likely to
be appropriate than values greater than the
<code>estimate_lambda()</code> output.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Estimating lambda for dynamic simulations with multiple FCMs</span></span>
<span><span class="va">example_fcms</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">conventional_fcms</span></span>
<span></span>
<span><span class="co"># Call lapply() to use estimate_lambda() on a list of FCMs.</span></span>
<span><span class="va">lambda_estimates</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span></span>
<span>  <span class="va">example_fcms</span>, <span class="kw">function</span><span class="op">(</span><span class="va">fcm</span><span class="op">)</span> <span class="fu">estimate_lambda</span><span class="op">(</span><span class="va">fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Since <code>estimate_lambda()</code> returns a different value for
each adjacency matrix, users will want to identify a value that will
work well with all FCMs being analyzed in each call to
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. Given this, we recommend estimating lambda
separately for each adjacency matrix and using the minimum lambda value
in <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. See example below:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Unlist the output lambda estimates to create a vector</span></span>
<span><span class="co"># and calculate the minimum value</span></span>
<span><span class="va">lambda_for_example_fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">lambda_estimates</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fcmconfr_obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fcmconfr.html">fcmconfr</a></span><span class="op">(</span></span>
<span>  adj_matrices <span class="op">=</span> <span class="va">example_fcms</span>,</span>
<span>  <span class="co"># Aggregation and Monte Carlo Sampling</span></span>
<span>  agg_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  num_mc_fcms <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Simulation</span></span>
<span>  initial_state_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  clamping_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  activation <span class="op">=</span> <span class="st">'rescale'</span>,</span>
<span>  squashing <span class="op">=</span> <span class="st">'sigmoid'</span>,</span>
<span>  lambda <span class="op">=</span> <span class="va">lambda_for_example_fcms</span>, <span class="co"># Pass lambda estimate into fcmconfr() !!!!!</span></span>
<span>  point_of_inference <span class="op">=</span> <span class="st">'final'</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  min_error <span class="op">=</span> <span class="fl">1e-05</span>,</span>
<span>  <span class="co"># Inference Estimation (bootstrap)</span></span>
<span>  ci_centering_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  confidence_interval <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  num_ci_bootstraps <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Runtime Options</span></span>
<span>  show_progress <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  n_cores <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  <span class="co"># Additional Options</span></span>
<span>  run_agg_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_mc_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_ci_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_zeroes_in_sampling <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  include_sims_in_output <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Note: Because <code>estimate_lambda()</code> returns a potential
lambda value, not an optimal lambda value, users are encouraged to
compare the impact of different lambda choices on their simulation
results (e.g. lambda = 1, lambda = 0.1, lambda = 0.01, …).</p>
</div>
</div>
<div class="section level3">
<h3 id="run-fcmconfr">3. Run <code>fcmconfr()</code><a class="anchor" aria-label="anchor" href="#run-fcmconfr"></a>
</h3>
<p>To run <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>, execute the output script created by
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code>.</p>
<p>Note: When using parallel processing, the following error can occur:
<code>Error in serialize(data, node$con) : error writing to connection</code>.
If this error occurs, restart the R session and rerun
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> with a lower value of <code>n_cores</code>.</p>
</div>
<div class="section level3">
<h3 id="explore-fcmconfr-results">4. Explore <code>fcmconfr()</code> Results<a class="anchor" aria-label="anchor" href="#explore-fcmconfr-results"></a>
</h3>
<p>The output of <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> is a large object with many
compomnents. Given this, the <code>fcmconfr</code> package includes
several functions designed to help users identify and explore the most
important outputs.</p>
<p>The figure below graphically represents the organization of an
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> object. Each branch represents a
<code>list</code> that can be accessed via
<code>fcmconfr_obj$...</code>.</p>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ffcmconfr_obj_tree.png" style="width:50.0%" alt="A tree illustrating the organization of an fcmconfr() output object. Three dots indicate additional data within a branch."><div class="figcaption">A tree illustrating the organization of an
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> output object. Three dots indicate additional
data within a branch.</div>
</div>
</div>
<p><em>Note: The aggregate and Monte Carlo elements illustrated above
will only be included in <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> objects if
<code>run_agg_calcs</code>, <code>run_mc_calcs</code>,
<code>run_ci_calcs</code>, and <code>include_sims_in_output</code> are
set to <code>TRUE</code> respectively in the original
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> call.</em></p>
<div class="section level4">
<h4 id="visualizing-fcmconfr-results">4.1 Visualizing <code>fcmconfr()</code> Results<a class="anchor" aria-label="anchor" href="#visualizing-fcmconfr-results"></a>
</h4>
<p>A plot of all inferences included in the output of
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> can be generated using the command
<code>plot(fcmconfr_obj)</code>.</p>
<p>To view documentation for the version of <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> used by
<code>fcmconfr</code> output objects, type <code><a href="../reference/plot.fcmconfr.html">?plot.fcmconfr</a></code>
into the console. This provides definitions for all possible inputs
(i.e., beyond the <code>fcmconfr</code> object itself) that can be used
to customize the figure.</p>
<p>An example call illustrating the defaults for each input has been
provided below:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot Defaults</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fcmconfr_obj</span>,</span>
<span>     interactive <span class="op">=</span> <span class="cn">FALSE</span>, <span class="co"># Set to TRUE to open shiny app</span></span>
<span>     <span class="co"># Plot Formatting Parameters</span></span>
<span>     filter_limit <span class="op">=</span> <span class="fl">1e-4</span>,</span>
<span>     xlim <span class="op">=</span> <span class="cn">NA</span>, <span class="co"># Axes limits - accepts c(lower_limit, upper_limit) inputs</span></span>
<span>     coord_flip <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>     <span class="co"># Plot Aesthetic Parameters</span></span>
<span>     mc_avg_and_CIs_color <span class="op">=</span> <span class="st">"blue"</span>,</span>
<span>     mc_inferences_color <span class="op">=</span> <span class="st">"blue"</span>,</span>
<span>     mc_inferences_alpha <span class="op">=</span> <span class="fl">0.1</span>, <span class="co"># scale from 0:transparent to 1:opaque</span></span>
<span>     mc_inferences_shape <span class="op">=</span> <span class="fl">3</span>, <span class="co"># R PCH point shape value (vertical cross)</span></span>
<span>     ind_inferences_color <span class="op">=</span> <span class="st">"black"</span>,</span>
<span>     ind_inferences_alpha <span class="op">=</span> <span class="fl">1</span>, <span class="co"># scale from 0:transparent to 1:opaque</span></span>
<span>     ind_inferences_shape <span class="op">=</span> <span class="fl">16</span>, <span class="co"># R PCH point shape value (small circle)</span></span>
<span>     agg_inferences_color <span class="op">=</span> <span class="st">"red"</span>,</span>
<span>     agg_inferences_alpha <span class="op">=</span> <span class="fl">1</span>, <span class="co"># scale from 0:transparent to 1:opaque</span></span>
<span>     agg_inferences_shape <span class="op">=</span> <span class="fl">17</span>, <span class="co"># R PCH point shape value (triangle)</span></span>
<span>     ind_ivfn_and_tfn_linewidth <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>     agg_ivfn_and_tfn_linewidth <span class="op">=</span> <span class="fl">0.6</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The <code>interactive</code> parameter in the call to
<code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> allows users to launch the plot inside a Shiny app
where the results from different analyses can be toggled on/off
(<code>interactive = TRUE</code>). This is a great option for data
exploration. <em>Note:</em> <em>It may be necessary to experiment with
font size within the app to clearly view axis labels</em>.</p>
<p>An example call, where the <code>interactive</code> parameter is set
to <code>TRUE</code> and the x-axis is constrained between -0.5 and 0.5
has been provided below:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fcmconfr_obj</span>,</span>
<span>     interactive <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>     xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Finteractive_plot_gui.png" style="width:100.0%" alt="A screenshot of an example fcmconfr() object launched inside the Shiny app (user controls on left; plot on right)."><div class="figcaption">A screenshot of an example
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> object launched inside the Shiny app (user
controls on left; plot on right).</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="retrieving-inferences">4.2 Retrieving Inferences<a class="anchor" aria-label="anchor" href="#retrieving-inferences"></a>
</h4>
<p>Simulation inferences (individual, aggregate, Monte Carlo) are the
main output from <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. They indicate how much each
node is influenced by a particular change or action. Inferences can be
accessed as follows:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">all_inferences</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span></span>
<span></span>
<span><span class="va">individual_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">all_inferences</span><span class="op">$</span><span class="va">individual_fcms</span><span class="op">$</span><span class="va">inferences</span></span>
<span><span class="va">aggregate_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">all_inferences</span><span class="op">$</span><span class="va">aggregate_fcm</span><span class="op">$</span><span class="va">inferences</span></span>
<span><span class="va">mc_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">all_inferences</span><span class="op">$</span><span class="va">monte_carlo_fcms</span><span class="op">$</span><span class="va">all_inferences</span></span>
<span><span class="va">CIs_of_avg_mc_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">all_inferences</span><span class="op">$</span><span class="va">monte_carlo_fcms</span><span class="op">$</span><span class="va">bootstrap</span><span class="op">$</span><span class="va">CIs_and_quantiles_by_node</span></span></code></pre></div>
<p>In addition to accessing inference data manually (as shown above),
<code>fcmconfr</code> provides the <code><a href="../reference/get_inferences.html">get_inferences()</a></code>
function to retrieve and store inference results.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fcmconfr_inferences</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_inferences.html">get_inferences</a></span><span class="op">(</span><span class="va">fcmconfr_obj</span>, analysis <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"individual"</span>, <span class="st">"aggregate"</span>, <span class="st">"mc"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The output of <code><a href="../reference/get_inferences.html">get_inferences()</a></code> is a <code>list</code> of
dataframes containing the inferences for each analysis. By default,
<code>analysis = c("individual", "aggregate", "mc")</code>, but users
can also specify a subset of these categories.</p>
<p>When <code>"mc"</code> is included and the box for bootstrapped
confidence intervals is checked, <code><a href="../reference/get_inferences.html">get_inferences()</a></code> returns
two types of MC outputs: (1) inferences from each empirical FCM
generated by Monte Carlo sampling and (2) a dataframe containing user
specified bootstrapped confidence bounds about the average of those
inferences.</p>
<div class="section level5">
<h5 id="advanced-inference-options">Advanced Inference Options<a class="anchor" aria-label="anchor" href="#advanced-inference-options"></a>
</h5>
<p>FCM inferences are calculated from FCM simulations, which can include
hundreds of iterations for each node in each FCM (individual, aggregate,
and Monte Carlo).</p>
<p>The <code><a href="../reference/get_inferences.html">get_inferences()</a></code> function returns standard inference
estimates only (e.g., the final point of convergence for each node or
the peak simulated value for each node, as specified in the original
call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>)</p>
<p>Users interested in calculating their own inferences directly from
simulation time-series can access thaat data as follows:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Simulations for individual_fcms</span></span>
<span><span class="va">individual_fcms_sims</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">individual_fcms</span><span class="op">$</span><span class="va">simulations</span></span>
<span></span>
<span><span class="co"># Simulations for aggregate_fcm</span></span>
<span><span class="va">aggregate_fcm_sims</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">aggregate_fcm</span><span class="op">$</span><span class="va">simulations</span></span>
<span></span>
<span><span class="co"># Simulations for monte_carlo_fcms</span></span>
<span><span class="va">monte_carlo_fcms_sims</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">monte_carlo_fcms</span><span class="op">$</span><span class="va">simulations</span></span></code></pre></div>
<p>These commands return a <code>list</code> of the simulations for
every adjacency matrix in a given analysis. Users can retrieve
simulations for a specific adjacency matrix (e.g.,
<code>adj_matrix_1</code> from <code>individual_fcms_sims</code>) as
follows:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_1</span> <span class="op">&lt;-</span> <span class="va">individual_fcms_sims</span><span class="op">$</span><span class="va">adj_matrix_1</span><span class="op">$</span><span class="va">simulations</span></span></code></pre></div>
<p>This returns both the <code>scenario_simulation</code> and
<code>baseline_simulation</code> data for a given adjacency matrix.</p>
<p>The <code>scenario_simulation</code> outputs incorporate the clamping
vector, so we observe the influence of continuously activating
(“clamping”) one (or some) nodes.</p>
<p>The <code>baseline_simulation</code> outputs incorporate ONLY the
initial state vector, so we observe the steady-state (or natural
behavior) of the system as a control.</p>
<p>Inferences are calculated by taking the difference between the two
(<code>scenario - baseline</code>). Different metrics are used for
<code>peak</code> vs <code>final</code> inferences as described
below:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Continuing from the example above</span></span>
<span></span>
<span><span class="co"># Get the state vectors for the scenario simulation</span></span>
<span><span class="va">scenario_state_vectors</span> <span class="op">&lt;-</span> <span class="va">sim_1</span><span class="op">$</span><span class="va">scenario_simulation</span><span class="op">$</span><span class="va">state_vectors</span></span>
<span></span>
<span><span class="co"># Get the state vectors for the baseline simulation</span></span>
<span><span class="va">baseline_state_vectors</span> <span class="op">&lt;-</span> <span class="va">sim_1</span><span class="op">$</span><span class="va">baseline_simulation</span><span class="op">$</span><span class="va">state_vectors</span></span>
<span></span>
<span><span class="co"># Calculating final inferences</span></span>
<span><span class="co"># Same as fcmconfr() output with point_of_inference = 'final'</span></span>
<span><span class="va">scenario_sim_final_values</span> <span class="op">&lt;-</span> <span class="va">scenario_state_vectors</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">scenario_state_vectors</span><span class="op">)</span>, <span class="op">]</span></span>
<span><span class="va">baseline_sim_final_values</span> <span class="op">&lt;-</span> <span class="va">baseline_state_vectors</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">baseline_state_vectors</span><span class="op">)</span>, <span class="op">]</span></span>
<span></span>
<span><span class="va">individual_fcm_1_final_inferences</span> <span class="op">&lt;-</span> <span class="va">scenario_sim_final_values</span> <span class="op">-</span> <span class="va">baseline_sim_final_values</span></span>
<span></span>
<span><span class="co"># Calculating peak inferences</span></span>
<span><span class="co"># Same as fcmconfr() output with point_of_inference = 'peak'</span></span>
<span><span class="co"># Note: Peak will not work unless all values in the clamping vector are 0!</span></span>
<span><span class="va">scenario_sim_peak_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span></span>
<span>  <span class="va">scenario_state_vectors</span>, <span class="fl">2</span>, <span class="kw">function</span><span class="op">(</span><span class="va">col</span><span class="op">)</span> <span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">col</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">col</span><span class="op">)</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">col</span><span class="op">)</span><span class="op">)</span><span class="op">]</span><span class="op">)</span><span class="op">}</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">baseline_sim_peak_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span></span>
<span>  <span class="va">baseline_state_vectors</span>, <span class="fl">2</span>, <span class="kw">function</span><span class="op">(</span><span class="va">col</span><span class="op">)</span> <span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">col</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">col</span><span class="op">)</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">col</span><span class="op">)</span><span class="op">)</span><span class="op">]</span><span class="op">)</span><span class="op">}</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">individual_fcm_1_peak_inferences</span> <span class="op">&lt;-</span> <span class="va">scenario_sim_peak_values</span> <span class="op">-</span> <span class="va">baseline_sim_peak_values</span></span></code></pre></div>
<p>Users can view <code>scenario</code> and <code>baseline</code>
simulation time-series for specific nodes (e.g.,
<code>Salinization.of.the.Reservoir</code>) as described below. The
difference between the <code>scenario</code> and <code>baseline</code>
time-series is the inference.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">salinization_scenario_time_series</span> <span class="op">&lt;-</span> <span class="va">scenario_state_vectors</span><span class="op">$</span><span class="va">Salinization.of.the.Reservoir</span></span>
<span><span class="va">salinization_baseline_time_series</span> <span class="op">&lt;-</span> <span class="va">baseline_state_vectors</span><span class="op">$</span><span class="va">Salinization.of.the.Reservoir</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">salinization_scenario_time_series</span>, type <span class="op">=</span> <span class="st">"l"</span>,</span>
<span>      xlab <span class="op">=</span> <span class="st">"Iteration"</span>, ylab <span class="op">=</span> <span class="st">"Activation Level"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">salinization_baseline_time_series</span>, lty <span class="op">=</span> <span class="st">"dashed"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"topright"</span>,          </span>
<span>       legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Baseline"</span>, <span class="st">"Scenario"</span><span class="op">)</span>,  </span>
<span>       lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>,         </span>
<span>       lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>   </span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ftime_series_data_plot.png" style="width:60.0%" alt="Scenario and Baseline time-series data for Salinization.of.the.Reservoir based on the first of the individual FCMs"><div class="figcaption">Scenario and Baseline time-series data for
Salinization.of.the.Reservoir based on the first of the individual
FCMs</div>
</div>
</div>
</div>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Ben Roston, Meg Rippy.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
