<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>fcmconfr • fcmconfr</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="fcmconfr">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">fcmconfr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/fcmconfr.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/fcmconfr_example.html">fcmconfr_Example</a></li>
    <li><a class="dropdown-item" href="../articles/Importing_FCMs.html">Importing_FCMs</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/bhroston/fcmconfr/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>fcmconfr</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/bhroston/fcmconfr/blob/main/vignettes/fcmconfr.Rmd" class="external-link"><code>vignettes/fcmconfr.Rmd</code></a></small>
      <div class="d-none name"><code>fcmconfr.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/bhroston/fcmconfr" class="external-link">fcmconfr</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="the-fcmconfr-workflow">The <code>fcmconfr</code> Workflow<a class="anchor" aria-label="anchor" href="#the-fcmconfr-workflow"></a>
</h2>
<p><code>fcmconfr</code> streamlines the process of conducting dynamic
simulations using fuzzy cognitive maps (FCMs). The package can (1)
analyze different types of FCMs (conventional, interval-value fuzzy
number, and triangular fuzzy number), (2) perform dynamic simulations on
one or more individual FCMs, (3) aggregate individual FCMs so that
dynamic simulations can be performed on the aggregate, and (4) estimate
uncertainty using Monte Carlo approaches. A typical fcmconfer workflow
includes the following four steps:</p>
<ol style="list-style-type: decimal">
<li><p>Import FCMs</p></li>
<li><p>Set simulation parameters using
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code></p></li>
<li><p>Run simulations using <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code></p></li>
<li><p>Explore outputs using <code><a href="../reference/get_inferences.html">get_inferences()</a></code> and
<code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code></p></li>
</ol>
<p>This guide walks through each of these steps, from data import to
visualization.</p>
<p>Note: This guide frequently references data from the
<code>sample_fcms</code> object that users can access after loading
<code>fcmconfr</code> via <code><a href="https://github.com/bhroston/fcmconfr" class="external-link">library(fcmconfr)</a></code>.</p>
<div class="section level3">
<h3 id="import-fcms">1. Import FCMs<a class="anchor" aria-label="anchor" href="#import-fcms"></a>
</h3>
<p><code>fcmconfr</code> can handle three different types of FCMs: (1)
conventional, where each edge weight is represented using numeric
values, (2) interval-value fuzzy number FCMs (IVFN-FCMs), where each
edge weight is represented using two numeric values (lower bound, upper
bound; i.e., an IVFN), and (3) triangular fuzzy number FCMs (TFN-FCMs),
where each edge weight is represented using three numeric values (lower
bound, mode, upper bound; i.e., a TFN).</p>
<p><em>A detailed guide for importing each FCM type in a maner
compatible with <code>fcmconfr</code> has been provided in a separate,
companion vignette (Importing_FCMs). A brief description of the typical
workflow used to import each FCM type has been provided below.</em></p>
<div class="section level4">
<h4 id="importing-conventional-fcms">1.1 Importing Conventional FCMs<a class="anchor" aria-label="anchor" href="#importing-conventional-fcms"></a>
</h4>
<p>Conventional FCMs can be imported as adjacency matrices, either from
excel or csv files using standard import functions (e.g., calls to
<code>readxl::read_excel()</code> or <code><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv()</a></code>). Users who
plan to use <code>fcmconfr</code> to analyze multiple FCMs together
should group them into a single <code>list</code> object.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Import Conventional FCMs into the Global Environment</span></span>
<span><span class="va">fcm_1</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">fcm_1_filepath</span><span class="op">)</span></span>
<span><span class="va">fcm_2</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">fcm_2_filepath</span><span class="op">)</span></span>
<span><span class="va">...</span></span>
<span><span class="va">fcm_n</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">fcm_n_filepath</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Group them together in a single list object</span></span>
<span><span class="va">fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">fcm_1</span>, <span class="va">fcm_2</span>, <span class="va">...</span>, <span class="va">fcm_n</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="importing-ivfn-fcms">1.2 Importing IVFN FCMs<a class="anchor" aria-label="anchor" href="#importing-ivfn-fcms"></a>
</h4>
<p>Because IVFN-FCMs have interval edge weights with lower and upper
bounds, separate adjacency matrices must be created and uploaded for
each bound (lower and upper). We can then use the <code>fcmconfr</code>
function <code><a href="../reference/make_adj_matrix_w_ivfns.html">make_adj_matrix_w_ivfns()</a></code> to combine the two,
creating a single adjacency matrix with interval edge weights. As noted
previously for conventional FCMs, users who plan to analyze multiple
IVFN FCMs together should group them into a single list object.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Import separate adjacency matrices representing the </span></span>
<span><span class="co"># lower and upper bounds of each edge weight</span></span>
<span><span class="va">ivfn_fcm_1_lower_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_lower_adj_matrix_filepath</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm_1_upper_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_upper_adj_matrix_filepath</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine the lower and upper adjacency matrices to make an IVFN FCM</span></span>
<span><span class="va">ivfn_fcm_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_adj_matrix_w_ivfns.html">make_adj_matrix_w_ivfns</a></span><span class="op">(</span></span>
<span>  <span class="va">ivfn_fcm_1_lower_adj_matrix</span>, <span class="va">ivfn_fcm_1_upper_adj_matrix</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># To analyze multiple IVFN FCMs, group them together </span></span>
<span><span class="co"># in a single list object</span></span>
<span><span class="va">ivfn_fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">ivfn_fcm_1</span>, <span class="va">ivfn_fcm_2</span>, <span class="va">...</span>, <span class="va">ivfn_fcm_n</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="importing-tfn-fcms">1.3 Importing TFN FCMs<a class="anchor" aria-label="anchor" href="#importing-tfn-fcms"></a>
</h4>
<p>The workflow for importing TFN FCMs is comparable to the workflow for
IVFN FCMs. The main differences are (1) the need to upload three
adjacency matrices rather than two (one for the lower bound, one for the
mode, and one for the upper bound) and (2) the function call to combine
these matrices is <code><a href="../reference/make_adj_matrix_w_tfns.html">make_adj_matrix_w_tfns()</a></code> (rather than
<code><a href="../reference/make_adj_matrix_w_ivfns.html">make_adj_matrix_w_ivfns()</a></code>). As noted previously, users who
plan to analyze multiple TFN-FCMs together should group them into a
single <code>list</code> object.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Import separate adjacency matrices representing the </span></span>
<span><span class="co"># lower and upper bounds as well as the mode  of each edge weight</span></span>
<span><span class="va">ivfn_fcm_1_lower_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_lower_adj_matrix_filepath</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm_1_mode_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_mode_adj_matrix_filepath</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm_1_upper_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu">readxl</span><span class="fu">::</span><span class="fu">read_excel</span><span class="op">(</span><span class="va">ivfn_fcm_1_upper_adj_matrix_filepath</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine the lower and upper adjacency matrices to make an IVFN FCM</span></span>
<span><span class="va">tfn_fcm_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_adj_matrix_w_tfns.html">make_adj_matrix_w_tfns</a></span><span class="op">(</span></span>
<span>  <span class="va">tfn_fcm_1_lower_adj_matrix</span>, <span class="va">tfn_fcm_1_mode_adj_matrix</span>, <span class="va">tfn_fcm_1_upper_adj_matrix</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># To analyze multiple TFN-FCMs, group them together</span></span>
<span><span class="co"># in a single list object</span></span>
<span><span class="va">tfn_fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">tfn_fcm_1</span>, <span class="va">tfn_fcm_2</span>, <span class="va">...</span>, <span class="va">tfn_fcm_n</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="interacting-with-ivfn-and-tfn-fcm-adjacency-matrix-elements">1.4 Interacting with IVFN and TFN FCM Adjacency Matrix Elements<a class="anchor" aria-label="anchor" href="#interacting-with-ivfn-and-tfn-fcm-adjacency-matrix-elements"></a>
</h4>
<p>Since users can make IVFN or TFN adjacency matrices by importing
matrices from files, they will rarely have to create an IVFN or TFN
matrix from scratch, but it is valuable to provide a code example of how
<code>fcmconfr</code> creates such objects. The example we provide below
is for an IVFN matrix. The approach for a TFN matrix is similar, but
uses three- rather than two-element lists.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># First, create a dataframe from a n x n matrix of lists</span></span>
<span><span class="va">ivfn_fcm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Then, place the ivfn/tfn within a list and define its location indices</span></span>
<span><span class="co"># Note that since ivfn_df is a matrix of lists, we have to define the new </span></span>
<span><span class="co"># ivfn object as the first element of the list at index [1, 2], hence the</span></span>
<span><span class="co"># need for [[1]] at the end.</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">0.6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0.7</span>, <span class="fl">0.8</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ivfn_fcm</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="../reference/ivfn.html">ivfn</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Fclipboard-1503284098.png" style="width:70.0%" alt="Note that the console output for ivfn_fcm will vary depending on whether it is loaded as a matrix or dataframe. As a dataframe it will print out the IVFN values, while as a matrix it will print out the object types, ivfn, 2. These differences do not impact the way we interact with ivfn_fcm."><div class="figcaption">Note that the console output for
<code>ivfn_fcm</code> will vary depending on whether it is loaded as a
matrix or dataframe. As a dataframe it will print out the IVFN values,
while as a matrix it will print out the object types,
<code>ivfn, 2</code>. These differences do not impact the way we
interact with <code>ivfn_fcm</code>.</div>
</div>
</div>
<p><br></p>
<p>To report the IVFN of a particular edge within an IVFN matrix, we can
call <code>ivfn_fcm[row, col]</code> which returns a <code>list</code>
object or <code>ivfn_fcm[row, col][[1]]</code> to return the first value
record in the <code>list</code> object, the IVFN itself.</p>
<div style="text-align: center;">
<p><img src="images%2Fivfn_example.png" style="width:50.0%"></p>
</div>
<p><br></p>
<p>To decompose an IVFN matrix into its upper and lower bounds, we can
run the following:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lower_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">ivfn_df</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="kw">function</span><span class="op">(</span><span class="va">element</span><span class="op">)</span> <span class="va">element</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">lower</span><span class="op">)</span></span>
<span><span class="va">upper_adj_matrix</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">ivfn_df</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="kw">function</span><span class="op">(</span><span class="va">element</span><span class="op">)</span> <span class="va">element</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">upper</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="viewing-fcms">1.5 Viewing FCMs<a class="anchor" aria-label="anchor" href="#viewing-fcms"></a>
</h4>
<p>Users may display FCMs in RStudio’s Viewer pane using
<code><a href="../reference/fcm_view.html">fcm_view()</a></code>, which plots an FCM (adjacency matrix) as a
<code>visNetwork</code> object. The resulting plot is interactive. Users
can manipulate node positions (i.e. node layout) to explore the FCM from
different angles. The function can be used with any of the three FCM
types recognized by <code>fcmconfr</code>. For IVFN and TFN-FCMs,
<code><a href="../reference/fcm_view.html">fcm_view()</a></code> plots the average edge weight to simplify the
output.</p>
<p>Two basic applications of <code><a href="../reference/fcm_view.html">fcm_view()</a></code> are illustrated
below, one that plots the FCM in the Viewer pane and one that plots the
FCM in a separate Shiny App.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Loading FCM from sample_fcms data</span></span>
<span><span class="va">adj_matrix</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">conventional_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Show FCM in Viewer Pane</span></span>
<span><span class="fu"><a href="../reference/fcm_view.html">fcm_view</a></span><span class="op">(</span>fcm_adj_matrix <span class="op">=</span> <span class="va">adj_matrix</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Show FCM in Separate Shiny App (returns a visNetwork object in the Global Environment)</span></span>
<span><span class="fu"><a href="../reference/fcm_view.html">fcm_view</a></span><span class="op">(</span>fcm_adj_matrix <span class="op">=</span> <span class="va">adj_matrix</span>, with_shiny <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ffcm_view_output.png" style="width:80.0%" alt="visNetwork Output of fcm_view. Drag nodes to rearrange layout."><div class="figcaption">visNetwork Output of fcm_view. Drag nodes to
rearrange layout.</div>
</div>
</div>
<p><code><a href="../reference/fcm_view.html">fcm_view()</a></code> has an additional argument
<code>with_shiny</code> (default <code>= FALSE</code>). If set to TRUE,
<code><a href="../reference/fcm_view.html">fcm_view()</a></code> records the <code>visNetwork</code> output in
the Global Environment as <code>view_fcm_visNetwork_output</code>. This
output stores node coordinates so nodes can be plotted in the same
position if manipulated by the user and can be interacted with as a
typical <code>visNetwork</code> object for users interested in
additional customization.</p>
<p>Note: At its core, <code><a href="../reference/fcm_view.html">fcm_view()</a></code> is just a call to a few
<code>visNetwork</code> functions. Users with experience with
<code>visNetwork</code> should feel free to plot FCMs directly with
<code>visNetwork</code> for greater flexibility.</p>
</div>
</div>
<div class="section level3">
<h3 id="set-simulation-parameters-using-fcmconfr_gui">2. Set Simulation Parameters using <code>fcmconfr_gui()</code><a class="anchor" aria-label="anchor" href="#set-simulation-parameters-using-fcmconfr_gui"></a>
</h3>
<p>The primary <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> function is the central function
of the package and requires specifying many different parameters. The
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> function is intended to help guide users
through that process.</p>
<p><code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> performs two tasks: (1) it launches a
Shiny app that lets users interactively select parameters and (2) it
outputs a corresponding call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> that users can
copy-and-paste to run in their own scripts.</p>
<p>No inputs are provided to <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code>, but the local
environment must have an individual FCM or a <code>list</code> object
containing multiple FCMs in order for <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> to be
used. Once <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> is running the user selects the
appropriate FCMs to analyze from a dropdown menu titled Adj. Matrix or
List of Adj. Matrices.</p>
<p>Matrices conforming to any of the above-noted FCM types
(conventional, IVFN, or TFN) can be selected for Analysis.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/fcmconfr_gui.html">fcmconfr_gui</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ffcmconfr_gui_screenshot.png" style="width:90.0%" alt="A screenshot of fcmconfr_gui() with an example list of FCMs selected in the dropdown menu."><div class="figcaption">A screenshot of <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> with
an example list of FCMs selected in the dropdown menu.</div>
</div>
</div>
<p>The GUI interface is organized into four tabs: Data, Agg. and Monte
Carlo Options, Simulation Options, and Runtime Options, which are
described further below.</p>
<ul>
<li>
<p>Data: The Data tab is where the user selects the FCMs they want
to analyze (drop-down menu titled Adj. Matrix or List of Adj. Matrices).
It is also where they manipulate values in the Initial State (Pulse)
Vector or Clamping Vector to identify the dynamic simulations they wish
to explore.</p>
<p><em>(Note: It is best practice to set every value in the Initial
State (Pulse) Vector to 1 and to set only the node(s)-of-interest to 1
in the Clamping Vector. In this configuration, the Initial State (Pulse)
Vector is used to determine the network’s state at equilibrium and the
clamping vector is used to determine the network’s state in response to
continuous activation of one or more nodes. The difference between the
two is a measure of the impact of those particular nodes on the
system.)</em></p>
</li>
<li>
<p>Agg. and Monte Carlo Options: The Agg. and Monte Carlo Options
tab is where the user specifies their preferences regarding FCM
aggregation and Monte Carlo sampling. Aggregation options are only
available when datasets contain multiple FCMs. Monte Carlo sampling
requires not available for individual conventional FCMs, but is for
individual IVFN-/TFN-FCMs as well as <code>list</code> objects of all
three FCM types. Aggregation and Monte Carlo options can be toggled off
to speed up the simulation process.</p>
<ul>
<li><p>Aggregation options allow the user to specify whether multiple
FCMs should be aggregated into a single collective model so that dynamic
simulations can be performed on the aggregate in addition to individual
FCMs. The user can specify the aggregation method (mean or median) and
whether or not zero-weighted edges should be included in the aggregation
process.</p></li>
<li><p>Monte Carlo options allow the user to specify whether Monte Carlo
sampling should be performed to estimate uncertainty in dynamic
simulation outputs. If yes, the user must specify the number of FCMs
that will be generated by Monte Carlo sampling (we recommend 1000 or
more). Dynamic simulations will be performed on each of these FCMs,
providing a range of inferences for each node, from which the median
state and quantiles (25<sup>th</sup>, 75<sup>th</sup>) will be
estimated. The user also has the option to perform nonparametric
bootstrapping and estimate confidence bounds about the average inference
for each node. These bounds are estimated at user specified confidence
limits (i.e., 95<sup>th</sup> percentile, 90<sup>th</sup> percentile,
etc.).</p></li>
</ul>
</li>
<li><p>Simulation Options: The Simulation Options tab is where users
specify the type of dynamic simulation to perform. This includes
specifying (1) the activation function (Kosko, Modified-Kosko, or
Rescale; default of Kosko), (2) the squashing function (sigmoid or
hyperbolic tangent; default of sigmoid), (3) the squashing function’s
key parameter, lambda (default of 1), (4) the final simulation output
(i.e., the peak estimate for each node or its final resting state;
default of final), (5) the maximum number of iterations to perform per
simulation (default of 100), and (6) the minimum acceptable error
between iterations (default of 1x10<sup>-5</sup>)</p></li>
<li><p>Runtime Options: The Runtime Options tab allows the user to
specify whether they want to use parallel processing and have a progress
bar displayed in the console at runtime. These options have no impact on
the simulation outputs. They do, however, influence how long
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> takes to run and what the user sees at
runtime.</p></li>
</ul>
<p>Note: A brief summary of each parameter within the
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> is provided in a glossary stored in a side
tab within the GUI. The side tab can be opened by clicking the arrow
symbol in the top-right-hand-corner of the GUI.</p>
<p>Once parameter selection is complete, click the Submit button at the
bottom of the GUI to receive the corresponding code for a call to
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. This code will be reported in the console. DO
NOT simply Exit the GUI. Doing so WILL NOT create a call to
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> and all previously entered information will be
lost. The following code is an example output from
<code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code>.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/fcmconfr.html">fcmconfr</a></span><span class="op">(</span></span>
<span>  adj_matrices <span class="op">=</span> <span class="va">sample_fcm_list</span>,</span>
<span>  <span class="co"># Aggregation and Monte Carlo Sampling</span></span>
<span>  agg_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  num_mc_fcms <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Simulation</span></span>
<span>  initial_state_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  clamping_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  activation <span class="op">=</span> <span class="st">'rescale'</span>,</span>
<span>  squashing <span class="op">=</span> <span class="st">'sigmoid'</span>,</span>
<span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  point_of_inference <span class="op">=</span> <span class="st">'final'</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  min_error <span class="op">=</span> <span class="fl">1e-05</span>,</span>
<span>  <span class="co"># Inference Estimation (bootstrap)</span></span>
<span>  ci_centering_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  confidence_interval <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  num_ci_bootstraps <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Runtime Options</span></span>
<span>  show_progress <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  n_cores <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  <span class="co"># Additional Options</span></span>
<span>  run_agg_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_mc_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_ci_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_zeroes_in_sampling <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  include_sims_in_output <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Once the call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> has been generated by the
GUI, copy-and-paste it into another file and define it as a variable
(see example below):</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fcmconfr_obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fcmconfr.html">fcmconfr</a></span><span class="op">(</span></span>
<span>  adj_matrices <span class="op">=</span> <span class="va">sample_fcm_list</span>,</span>
<span>  <span class="co"># Aggregation and Monte Carlo Sampling</span></span>
<span>  agg_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  num_mc_fcms <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Simulation</span></span>
<span>  initial_state_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  clamping_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  activation <span class="op">=</span> <span class="st">'rescale'</span>,</span>
<span>  squashing <span class="op">=</span> <span class="st">'sigmoid'</span>,</span>
<span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  point_of_inference <span class="op">=</span> <span class="st">'final'</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  min_error <span class="op">=</span> <span class="fl">1e-05</span>,</span>
<span>  <span class="co"># Inference Estimation (bootstrap)</span></span>
<span>  ci_centering_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  confidence_interval <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  num_ci_bootstraps <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Runtime Options</span></span>
<span>  show_progress <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  n_cores <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  <span class="co"># Additional Options</span></span>
<span>  run_agg_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_mc_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_ci_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_zeroes_in_sampling <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  include_sims_in_output <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="section level4">
<h4 id="optional-estimating-lambda">Optional: Estimating Lambda<a class="anchor" aria-label="anchor" href="#optional-estimating-lambda"></a>
</h4>
<p>The <code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> sets lambda to a value of 1 by
default but there is no one “correct” value for <code>lambda</code>. In
fact, a value for lambda that works with one FCM may not cooperate well
with another.</p>
<p><code>fcmconfr</code> offers the <code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code>
function to give users a starting point in selecting lambda, which
implements an algorithm developed in Koutsellis et al. (2022) - <a href="https://doi.org/10.1007/s12351-022-00717-x" class="external-link uri">https://doi.org/10.1007/s12351-022-00717-x</a>.</p>
<p><code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> returns the maximum lambda value that
guarantees FCM simulation convergence (i.e. the max. usable value for
lambda) based on the input adjacency matrix and varies based on which
squashing function will be used in the simulation, <code>sigmoid</code>
or <code>tanh</code>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">example_fcm</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">conventional_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="fu"><a href="../reference/estimate_lambda.html">estimate_lambda</a></span><span class="op">(</span><span class="va">example_fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/estimate_lambda.html">estimate_lambda</a></span><span class="op">(</span><span class="va">example_fcm</span>, squashing <span class="op">=</span> <span class="st">"tanh"</span><span class="op">)</span></span></code></pre></div>
<p>The <a href="https://doi.org/10.1007/s12351-022-00717-x" class="external-link">Koutsellis
et al. (2022)</a> algorithm is limited to conventional FCMs only, but if
given an IVFN-FCM or TFN-FCM <code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> will create
a conventional FCM of their average edge weights to inform its
calculations.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">example_ivfn_fcm</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">ivfn_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">example_tfn_fcm</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">tfn_fcms</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="fu"><a href="../reference/estimate_lambda.html">estimate_lambda</a></span><span class="op">(</span><span class="va">example_ivfn_fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/estimate_lambda.html">estimate_lambda</a></span><span class="op">(</span><span class="va">example_tfn_fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span></code></pre></div>
<p>It is important to note that <code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> returns a
<u>potential</u> lambda value, not a perfect lambda value, though values
less than the <code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> output are more likely to
be appropriate than values greater than the
<code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> output.</p>
<p>Since <code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> returns a different value for
each adjacency matrix, users will want to determine a value of lambda
that will work well with all FCMs being analyzed in a call to
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. We recommend using
<code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> on each adjacency matrix and using the
minimum value as the lambda input for <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">example_fcms</span> <span class="op">&lt;-</span> <span class="va">sample_fcms</span><span class="op">$</span><span class="va">simple_fcms</span><span class="op">$</span><span class="va">conventional_fcms</span></span>
<span></span>
<span><span class="co"># This example estimates lambda for a simulation using </span></span>
<span><span class="co"># the sigmoid squashing function.</span></span>
<span></span>
<span><span class="co"># Use lapply() to use estimate_lambda() on a list of FCMs.</span></span>
<span><span class="va">lambda_estimates</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span></span>
<span>  <span class="va">example_fcms</span>, <span class="kw">function</span><span class="op">(</span><span class="va">fcm</span><span class="op">)</span> <span class="fu"><a href="../reference/estimate_lambda.html">estimate_lambda</a></span><span class="op">(</span><span class="va">fcm</span>, squashing <span class="op">=</span> <span class="st">"sigmoid"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Since lapply() returns a list() object and min() requires</span></span>
<span><span class="co"># a vector input, have to use unlist()</span></span>
<span><span class="va">lambda_for_example_fcms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">lambda_estimates</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>In addition to using <code><a href="../reference/estimate_lambda.html">estimate_lambda()</a></code> as a guide, users
are encouraged to compare how different values of lambda influence their
results (e.g. lambda = 1, lambda = 0.1, lambda = 0.01, …).</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fcmconfr_obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fcmconfr.html">fcmconfr</a></span><span class="op">(</span></span>
<span>  adj_matrices <span class="op">=</span> <span class="va">example_fcms</span>,</span>
<span>  <span class="co"># Aggregation and Monte Carlo Sampling</span></span>
<span>  agg_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  num_mc_fcms <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Simulation</span></span>
<span>  initial_state_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  clamping_vector <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  activation <span class="op">=</span> <span class="st">'rescale'</span>,</span>
<span>  squashing <span class="op">=</span> <span class="st">'sigmoid'</span>,</span>
<span>  lambda <span class="op">=</span> <span class="va">lambda_for_example_fcms</span>, <span class="co"># Pass lambda estimate into fcmconfr() !!!!!</span></span>
<span>  point_of_inference <span class="op">=</span> <span class="st">'final'</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  min_error <span class="op">=</span> <span class="fl">1e-05</span>,</span>
<span>  <span class="co"># Inference Estimation (bootstrap)</span></span>
<span>  ci_centering_function <span class="op">=</span> <span class="st">'mean'</span>,</span>
<span>  confidence_interval <span class="op">=</span> <span class="fl">0.95</span>,</span>
<span>  num_ci_bootstraps <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co"># Runtime Options</span></span>
<span>  show_progress <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  n_cores <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  <span class="co"># Additional Options</span></span>
<span>  run_agg_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_mc_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  run_ci_calcs <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  include_zeroes_in_sampling <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  include_sims_in_output <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="run-fcmconfr">3. Run <code>fcmconfr()</code><a class="anchor" aria-label="anchor" href="#run-fcmconfr"></a>
</h3>
<p><code><a href="../reference/fcmconfr_gui.html">fcmconfr_gui()</a></code> has done all the hard work of putting
together the call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. Running
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> is now as simple as executing that output
script.</p>
<p>Note: When using parallel processing, the following error can occur:
<code>Error in serialize(data, node$con) : error writing to connection</code>.
This appears to be a potential bug with the <code>foreach</code>
package. Try restarting the R session and a) re-running
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> or b) re-running <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> with a
lower value for <code>n_cores</code>.</p>
</div>
<div class="section level3">
<h3 id="explore-fcmconfr-results">4. Explore <code>fcmconfr()</code> Results<a class="anchor" aria-label="anchor" href="#explore-fcmconfr-results"></a>
</h3>
<p>The output of <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> is a large object that contains
a lot of data. The <code>fcmconfr</code> package includes several
functions to help users identify and explore the most important
outputs.</p>
<p>The organization of an <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> output object is
illustrated below, where each branch represents a <code>list</code>
stored within the output object that can be accessed via the
<code>$</code> (e.g. <code>fcmconfr_obj$...</code>)</p>
<p>Note that aggregate and Monte Carlo FCM data will not be included if
those analyses were not performed in the call to <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>
that created the output.</p>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ffcmconfr_obj_tree.png" style="width:50.0%" alt="A tree illustrating the organization of an fcmconfr() output object. Three dots indicate additional data within a branch."><div class="figcaption">A tree illustrating the organization of an
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> output object. Three dots indicate additional
data within a branch.</div>
</div>
</div>
<div class="section level4">
<h4 id="visualizing-fcmconfr-results">4.1 Visualizing <code>fcmconfr()</code> Results<a class="anchor" aria-label="anchor" href="#visualizing-fcmconfr-results"></a>
</h4>
<p>A plot of all inferences included in the output of
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> can be generated using the command
<code>plot(fcmconfr_obj)</code>.</p>
<p>To view the documentation for the version of <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> used
for <code>fcmconfr</code> output objects, type
<code><a href="../reference/plot.fcmconfr.html">?plot.fcmconfr</a></code> into the console. This provides definitions
for all possible inputs to plot (i.e., beyond the <code>fcmconfr</code>
object itself) that can be used to customize the resultant figure. Most
inputs describe how points from different analyses are plotted (color,
shape, transparency).</p>
<p>The defaults for each input are indicated below:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot Defaults</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fcmconfr_obj</span>,</span>
<span>     interactive <span class="op">=</span> <span class="cn">FALSE</span>, <span class="co"># Set to TRUE to open shiny app</span></span>
<span>     <span class="co"># Plot Formatting Parameters</span></span>
<span>     filter_limit <span class="op">=</span> <span class="fl">1e-4</span>,</span>
<span>     xlim <span class="op">=</span> <span class="cn">NA</span>, <span class="co"># Axes limits - accepts c(lower_limit, upper_limit) inputs</span></span>
<span>     coord_flip <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>     <span class="co"># Plot Aesthetic Parameters</span></span>
<span>     mc_avg_and_CIs_color <span class="op">=</span> <span class="st">"blue"</span>,</span>
<span>     mc_inferences_color <span class="op">=</span> <span class="st">"blue"</span>,</span>
<span>     mc_inferences_alpha <span class="op">=</span> <span class="fl">0.1</span>, <span class="co"># scale from 0:transparent to 1:opaque</span></span>
<span>     mc_inferences_shape <span class="op">=</span> <span class="fl">3</span>, <span class="co"># R PCH point shape value (vertical cross)</span></span>
<span>     ind_inferences_color <span class="op">=</span> <span class="st">"black"</span>,</span>
<span>     ind_inferences_alpha <span class="op">=</span> <span class="fl">1</span>, <span class="co"># scale from 0:transparent to 1:opaque</span></span>
<span>     ind_inferences_shape <span class="op">=</span> <span class="fl">16</span>, <span class="co"># R PCH point shape value (small circle)</span></span>
<span>     agg_inferences_color <span class="op">=</span> <span class="st">"red"</span>,</span>
<span>     agg_inferences_alpha <span class="op">=</span> <span class="fl">1</span>, <span class="co"># scale from 0:transparent to 1:opaque</span></span>
<span>     agg_inferences_shape <span class="op">=</span> <span class="fl">17</span>, <span class="co"># R PCH point shape value (triangle)</span></span>
<span>     ind_ivfn_and_tfn_linewidth <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>     agg_ivfn_and_tfn_linewidth <span class="op">=</span> <span class="fl">0.6</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The <code>interactive</code> parameter allows the user to launch the
plot inside a Shiny app wherein the results from different analyses can
be toggled on/off (<code>interactive = TRUE</code>). This is a great
option for exploring early results. (<em>It may be necessary to
experiment with font size within the app to clearly view axis
labels</em>). An example call where the <code>interactive</code>
parameter is set to <code>TRUE</code> and the x-axis is constrained
between -0.5 and 0.5 has been provided below:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fcmconfr_obj</span>,</span>
<span>     interactive <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>     xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Finteractive_plot_gui.png" style="width:100.0%" alt="A screenshot of an example fcmconfr() object launched inside the Shiny app (user controls on left; plot on right)."><div class="figcaption">A screenshot of an example
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> object launched inside the Shiny app (user
controls on left; plot on right).</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="getting-inferences">4.2 Getting Inferences<a class="anchor" aria-label="anchor" href="#getting-inferences"></a>
</h4>
<p>Simulation inferences (individual, aggregate, Monte Carlo) are the
main output from <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. They indicate how much each
node is influenced by a particular change or action. Inferences can be
accessed from the output of <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> as follows:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">individual_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">individual_fcms</span><span class="op">$</span><span class="va">inferences</span></span>
<span><span class="va">aggregate_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">aggregate_fcm</span><span class="op">$</span><span class="va">inferences</span></span>
<span><span class="va">mc_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">monte_carlo_fcms</span><span class="op">$</span><span class="va">all_inferences</span></span>
<span><span class="va">CIs_of_avg_mc_fcm_inferences</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">monte_carlo_fcms</span><span class="op">$</span><span class="va">bootstrap</span><span class="op">$</span><span class="va">CIs_and_quantiles_by_node</span></span></code></pre></div>
<p>In addition to accessing inference data manually (as shown above),
<code>fcmconfr</code> provides the <code><a href="../reference/get_inferences.html">get_inferences()</a></code>
function to retrieve and store inference results.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fcmconfr_inferences</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_inferences.html">get_inferences</a></span><span class="op">(</span><span class="va">fcmconfr_obj</span>, analysis <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"individual"</span>, <span class="st">"aggregate"</span>, <span class="st">"mc"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The output of <code><a href="../reference/get_inferences.html">get_inferences()</a></code> is a <code>list</code> of
dataframes that contain the inferences for each analysis. By default,
<code>analysis = c("individual", "aggregate", "mc")</code>, but users
can also specify a subset of these categories.</p>
<p>When <code>"mc"</code> is included and the box for bootstrapped
confidence intervals is checked, <code><a href="../reference/get_inferences.html">get_inferences()</a></code> returns
two types of MC outputs: (1) inferences from each empirical FCM
generated by Monte Carlo sampling of input FCMs and (2) a dataframe that
includes the user specified bootstrapped confidence bounds about the
average of those inferences.</p>
<div class="section level5">
<h5 id="whats-in-an-inference">What’s in an Inference?<a class="anchor" aria-label="anchor" href="#whats-in-an-inference"></a>
</h5>
<p><em>Note: This subsection covers FCM theory and is included only for
the benefit of advanced users that are interested in getting more
information from the <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code> output.</em></p>
<p>Inferences are calculated from the final values of an FCM simulation
which can include hundreds of iterations across every node in an FCM for
every FCM (individual, aggregate, and monte carlo) in a call to
<code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>.</p>
<p>The <code><a href="../reference/get_inferences.html">get_inferences()</a></code> function returns, naturally, only
inferences which are typical outputs across FCM studies.</p>
<p>Users interested in the many simulations’ time-series can still
access them from the output of <code><a href="../reference/fcmconfr.html">fcmconfr()</a></code>. The
<code>simulations</code> list under each of the analysis results in the
<code>inferences</code> list stores the raw simulation data (which
includes the time-series for each simulation).</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Simulations for individual_fcms</span></span>
<span><span class="va">individual_fcms_sims</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">individual_fcms</span><span class="op">$</span><span class="va">simulations</span></span>
<span></span>
<span><span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">individual_fcms</span><span class="op">$</span><span class="va">simulations</span><span class="op">$</span><span class="va">adj_matrix_1</span></span>
<span></span>
<span><span class="co"># Simulations for aggregate_fcm</span></span>
<span><span class="va">aggregate_fcm_sims</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">aggregate_fcm</span><span class="op">$</span><span class="va">simulations</span></span>
<span></span>
<span><span class="co"># Simulations for monte_carlo_fcms</span></span>
<span><span class="va">monte_carlo_fcms_sims</span> <span class="op">&lt;-</span> <span class="va">fcmconfr_obj</span><span class="op">$</span><span class="va">inferences</span><span class="op">$</span><span class="va">monte_carlo_fcms</span><span class="op">$</span><span class="va">simulations</span></span></code></pre></div>
<p>The <code>simulations</code> lists contain the simulation data for
every adjacency matrix simulated within that analysis. For example, the
simulation results for the first individual adjacency matrix can be
accessed via:</p>
<p><code>fcmconfr_obj$inferences$individual_fcms$simulations$adj_matrix_1$simulations</code></p>
<p>or just <code>individual_fcms_sims$adj_matrix_1$simulations</code> if
following along the previous code snippet.</p>
<p>To access the time-series data used to calculate an inference for a
particular FCM (individual, aggregate, or Monte Carlo), find the
$simulations list for that FCM and get both the
<code>scenario_simulation</code> and <code>baseline_simulation</code>
state vectors dataframes.</p>
<p>The <code>scenario_simulation</code> incorporates the clamping
vector, so we observe the influence of continuously activating
(“clamping”) one (or some) nodes.</p>
<p>The <code>baseline_simulation</code> incorporates ONLY the initial
state vector, so we observe the steady-state (or natural behavior) of
the system as a control.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Continuing the example getting the time-series</span></span>
<span><span class="co"># for the first individual FCM...</span></span>
<span><span class="co"># individual_fcms_sims &lt;- fcmconfr_obj$inferences$individual_fcms$simulations</span></span>
<span></span>
<span><span class="co"># Get the state vectors from the scenario simulation</span></span>
<span><span class="va">scenario_state_vectors</span> <span class="op">&lt;-</span> <span class="va">individual_fcms_sims</span><span class="op">$</span><span class="va">adj_matrix_1</span><span class="op">$</span><span class="va">simulations</span><span class="op">$</span><span class="va">scenario_simulation</span><span class="op">$</span><span class="va">state_vectors</span></span>
<span></span>
<span><span class="co"># Get the state vectors from the baseline simulation</span></span>
<span><span class="va">baseline_state_vectors</span> <span class="op">&lt;-</span> <span class="va">individual_fcms_sims</span><span class="op">$</span><span class="va">adj_matrix_1</span><span class="op">$</span><span class="va">simulations</span><span class="op">$</span><span class="va">baseline_simulation</span><span class="op">$</span><span class="va">state_vectors</span></span></code></pre></div>
<p>The final inferences are calculated by subtracting the final values
of each node in the baseline_state_vectors dataframe from the final
values of each node in the scenario_state_vectors dataframe.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">scenario_sim_final_values</span> <span class="op">&lt;-</span> <span class="va">scenario_state_vectors</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">scenario_state_vectors</span><span class="op">)</span>, <span class="op">]</span></span>
<span><span class="va">baseline_sim_final_values</span> <span class="op">&lt;-</span> <span class="va">baseline_state_vectors</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">baseline_state_vectors</span><span class="op">)</span>, <span class="op">]</span></span>
<span></span>
<span><span class="va">individual_fcm_1_inferences</span> <span class="op">&lt;-</span> <span class="va">scenario_sim_final_values</span> <span class="op">-</span> <span class="va">baseline_sim_final_values</span></span>
<span></span>
<span><span class="co"># Which are the same as given in the fcmconfr() output</span></span>
<span><span class="co"># fcmconfr_obj$inferences$individual_fcms$inferences[1, ]</span></span>
<span><span class="co"># Note that fcmconfr() always returns the clamping_vector() </span></span>
<span><span class="co"># value for each node if given.</span></span></code></pre></div>
<p>Users can view the time-series for different nodes by plotting the
column for that node in both the scenario and baseline simulations. The
following example code plots the <code>scenario</code> and
<code>baseline</code> time-series for the node
<code>Salinization.of.the.Reservoir</code> in the first of the
individual FCMs. The difference between the final values represents the
inference.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">salinization_scenario_time_series</span> <span class="op">&lt;-</span> <span class="va">scenario_state_vectors</span><span class="op">$</span><span class="va">Salinization.of.the.Reservoir</span></span>
<span><span class="va">salinization_baseline_time_series</span> <span class="op">&lt;-</span> <span class="va">baseline_state_vectors</span><span class="op">$</span><span class="va">Salinization.of.the.Reservoir</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">salinization_scenario_time_series</span>, type <span class="op">=</span> <span class="st">"l"</span>,</span>
<span>      xlab <span class="op">=</span> <span class="st">"Iteration"</span>, ylab <span class="op">=</span> <span class="st">"Activation Level"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">salinization_baseline_time_series</span>, lty <span class="op">=</span> <span class="st">"dashed"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"topright"</span>,          </span>
<span>       legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Baseline"</span>, <span class="st">"Scenario"</span><span class="op">)</span>,  </span>
<span>       lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>,         </span>
<span>       lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>   </span></code></pre></div>
<div style="text-align: center;">
<div class="float">
<img src="images%2Ftime_series_data_plot.png" style="width:60.0%" alt="Scenario and Baseline time-series data for Salinization.of.the.Reservoir based on the first of the individual FCMs"><div class="figcaption">Scenario and Baseline time-series data for
Salinization.of.the.Reservoir based on the first of the individual
FCMs</div>
</div>
</div>
</div>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Ben Roston.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
